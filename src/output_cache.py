# DO NOT EDIT. This file is automatically generated by Duende.
import asyncio
import hashlib
import os
import pickle
import pathlib
from typing import NamedTuple

from agent_command import VariableName, VariableValueInt, VariableValueStr, VariableValue, VariableMap


class CacheKey(NamedTuple):
  workflow: str
  conversation: str


DEFAULT_PATH = pathlib.Path.home() / ".duende" / "cache"


class OutputCache:
  """Cache of outputs of conversations."""

  def __init__(self, base_dir: pathlib.Path) -> None:
    self._base_dir = base_dir

  async def _ensure_cache_dir(self) -> None:
    """Creates the cache directory if it doesn't exist.

    {{ðŸ¦” Uses async io.}}
    """
    # âœ¨ ensure cache dir
    await asyncio.to_thread(os.makedirs, self._base_dir, exist_ok=True)
    # âœ¨

  def _get_path_for_key(self, key: CacheKey) -> pathlib.Path:
    """Generates a stable, unique filepath for a given cache key.

    We create a hash from the key to get a safe and unique filename.
    Example: ('workflow_x', 'conversation_x') -> '<cache_dir>/<sha256_hash>.pkl'

    The hash is a function of key.workflow and key.conversation.
    """
    # âœ¨ get path for key
    hash_input = f"{key.workflow}-{key.conversation}"
    hash_output = hashlib.sha256(hash_input.encode()).hexdigest()
    return self._base_dir / f"{hash_output}.pkl"
    # âœ¨

  async def save(self, key: CacheKey, value: VariableMap) -> None:
    """Atomically saves a single conversation (VariableMap) to the cache.

    Writes to a temporary file first, then atomically renames it.
    This prevents other processes from reading a half-written file.

    Does not catch exceptions; let's them bubble up.

    {{ðŸ¦” Uses async io.}}
    """
    output = self._get_path_for_key(key)
    tmp_output = output.with_suffix(f"{output.suffix}.tmp")

    # âœ¨ use pickle to write both `key` and `value` to tmp_output
    def _do_pickle_dump() -> None:
      with open(tmp_output, "wb") as f:
        pickle.dump((key, value), f)

    await asyncio.to_thread(_do_pickle_dump)
    # âœ¨
    # âœ¨ rename tmp_output to output
    await asyncio.to_thread(os.rename, tmp_output, output)
    # âœ¨

  async def load(self, key: CacheKey) -> VariableMap | None:
    """Loads a single conversation from its cache file.

    Returns None if the file doesn't exist.

    If the file is corrupt, lets exceptions bubble up.

    {{ðŸ¦” Uses async io.}}
    """
    filepath = self._get_path_for_key(key)
    if not filepath.exists():
      return None
    # âœ¨ use pickle to load `key` and `value`
    def _do_pickle_load():
      with open(filepath, "rb") as f:
        _, value = pickle.load(f)
      return value

    return await asyncio.to_thread(_do_pickle_load)
    # âœ¨
