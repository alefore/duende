# DO NOT EDIT. This file is automatically generated by Duende.
import asyncio
import hashlib
import os
import json
import pathlib
from typing import NamedTuple

from agent_loop_options import AgentLoopOptions, BaseAgentLoop, BaseAgentLoopFactory
from agent_command import VariableName, VariableValueInt, VariableValueStr, VariableValue, VariableMap


class CacheKey(NamedTuple):
  workflow: str
  conversation: str


DEFAULT_PATH = pathlib.Path.home() / ".duende" / "cache"


class OutputCache:
  """Cache of outputs of conversations."""

  def __init__(self, base_dir: pathlib.Path) -> None:
    self._base_dir = base_dir

  def _get_path_for_key(self, key: CacheKey) -> pathlib.Path:
    """Generates a stable, unique filepath for a given cache key.

    We create a hash from the key to get a safe and unique filename.
    Example: ('workflow_x', 'conversation_x', 'extra_x')
      -> '<cache_dir>/<sha256_hash>.pkl'

    The hash is a function of all parameters in `key`.

    {{ðŸ¦” Output is a file directly in `self._base_dir`.}}
    {{ðŸ¦” Changing any of the parameters in `key` results in a different hash.}}
    """
    # âœ¨ get path for key
    hash_input = f"{key.workflow}-{key.conversation}"
    hash_output = hashlib.sha256(hash_input.encode()).hexdigest()
    return self._base_dir / f"{hash_output}.json"
    # âœ¨

  async def save(self, key: CacheKey, value: VariableMap) -> None:
    """Atomically saves a single conversation (VariableMap) to the cache.

    Writes to a temporary file first, then atomically renames it.
    This prevents other processes from reading a half-written file.

    Does not catch exceptions; let's them bubble up.

    {{ðŸ¦” Uses async io.}}
    """
    output = self._get_path_for_key(key)
    tmp_output = output.with_suffix(f"{output.suffix}.tmp")
    # âœ¨ create cache dir if it doesn't exist
    await asyncio.to_thread(os.makedirs, self._base_dir, exist_ok=True)
    # âœ¨
    # âœ¨ use json to write both `key` and `value` to tmp_output
    class PathEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, pathlib.Path):
                return str(obj)
            return json.JSONEncoder.default(self, obj)

    def _do_json_dump() -> None:
      with open(tmp_output, "w") as f:
        json_data = {"key": key._asdict(), "value": value}
        json.dump(json_data, f, cls=PathEncoder, indent=2)

    await asyncio.to_thread(_do_json_dump)
    # âœ¨
    # âœ¨ rename tmp_output to output
    await asyncio.to_thread(os.rename, tmp_output, output)
    # âœ¨

  async def load(self, key: CacheKey) -> VariableMap | None:
    """Loads a single conversation from its cache file.

    Returns None if the file doesn't exist.

    If the file is corrupt, lets exceptions bubble up.

    {{ðŸ¦” Uses async io.}}
    """
    filepath = self._get_path_for_key(key)
    if not filepath.exists():
      return None
    # âœ¨ use json to load data and return value
    def _do_json_load() -> VariableMap:
      with open(filepath, "r") as f:
        json_data = json.load(f)
      return VariableMap(json_data["value"])

    return await asyncio.to_thread(_do_json_load)
    # âœ¨


class CachingDelegatingAgentLoop(BaseAgentLoop):

  def __init__(self, workflow: str, cache: OutputCache, delegate: BaseAgentLoop,
               options: AgentLoopOptions):
    self._workflow = workflow
    self._cache = cache
    self._delegate = delegate
    self._options = options

  async def run(self) -> VariableMap:
    key = CacheKey(self._workflow, self._options.conversation.name())
    cache_output = await self._cache.load(key)
    match cache_output:
      case dict(data):
        return data
      case None:
        output = await self._delegate.run()
        await self._cache.save(key, output)
        return output
    assert f"Invalid data: {cache_output}"
    return VariableMap({})


class CachingDelegatingAgentLoopFactory(BaseAgentLoopFactory):

  def __init__(self, workflow: str, cache: OutputCache,
               delegate: BaseAgentLoopFactory) -> None:
    self._workflow = workflow
    self._cache = cache
    self._delegate = delegate

  def new(self, options: AgentLoopOptions) -> BaseAgentLoop:
    return CachingDelegatingAgentLoop(self._workflow, self._cache,
                                      self._delegate.new(options), options)