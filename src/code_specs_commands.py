# DO NOT EDIT. This file is automatically generated by Duende.
import asyncio
import logging
import os
import pathlib
import re
from typing import Any

import aiofiles

from agent_command import AgentCommand, Argument, ArgumentContentType, CommandOutput, CommandSyntax, VariableMap, VariableName
from file_access_policy import FileAccessPolicy
from code_specs import comment_string, ExpandedMarker, FileExtension, get_expanded_markers, get_markers, MarkerChar, MarkerName, MarkersOverlapError, MarkerImplementation, reindent_code
from validation import ValidationManager


def _get_file_extension(path: pathlib.Path) -> FileExtension:
  """Returns the file extension (sans the dot), handling `.dm.foo` files.

  {{ðŸ¦” Given 'foo.py', returns 'py'.}}
  {{ðŸ¦” Given 'src/foo.dm.py', returns 'py'.}}
  """
  # âœ¨ get file extension
  file_extension_str = path.suffix.lstrip('.')
  if '.dm.' in path.name:
    parts = path.name.split('.')
    try:
      dm_index = parts.index('dm')
      if dm_index + 1 < len(parts):
        file_extension_str = parts[dm_index + 1]
      else:
        file_extension_str = ''
    except ValueError:
      file_extension_str = path.suffix.lstrip('.')
  return FileExtension(file_extension_str)
  # âœ¨


class UpdateDuendeMarkerImplementationCommand(AgentCommand):

  def __init__(self,
               file_access_policy: FileAccessPolicy,
               validation_manager: ValidationManager | None = None):
    self._file_access_policy = file_access_policy
    self._validation_manager = validation_manager

  def Name(self) -> str:
    return "update_duende_marker_implementation"

  def Syntax(self) -> CommandSyntax:
    return CommandSyntax(
        name=VariableName("update_duende_marker_implementation"),
        description="Updates a Duende marker implementation block in a file.",
        arguments=[
            Argument(
                name=VariableName("path"),
                arg_type=ArgumentContentType.PATH_INPUT_OUTPUT,
                description="The path of the file to update."),
            Argument(
                name=VariableName("marker_name"),
                arg_type=ArgumentContentType.STRING,
                description="The name of the marker to update."),
            Argument(
                name=VariableName("content"),
                arg_type=ArgumentContentType.STRING,
                description=(
                    "The new content for the marker implementation block. "
                    "This will replace all lines between the "
                    "\"âœ¨ {marker_name}\" comment "
                    "and the following \"âœ¨\" comment (in `path`)."))
        ],
        output_description="A string describing the result of the operation.")

  async def run(self, inputs: VariableMap) -> CommandOutput:
    path_str = str(inputs[VariableName("path")])
    marker_name_str = str(inputs[VariableName("marker_name")])
    content = str(inputs[VariableName("content")])

    path = pathlib.Path(path_str)

    if not self._file_access_policy.allow_access(path_str):
      # âœ¨ return error CommandOutput policy
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"File access denied for writing to {path_str}.",
          summary=f"Failed to update marker in {path_str}: access denied.")
      # âœ¨

    try:
      async with aiofiles.open(path, mode='r') as f:
        lines = (await f.read()).splitlines()
    except Exception as e:
      # âœ¨ return read error CommandOutput
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Error reading file {path_str}: {str(e)}",
          summary=f"Failed to update marker in {path_str}: read error.")
      # âœ¨

    blocks = [
        m for m in get_expanded_markers(path) if m.name == marker_name_str
    ]

    # âœ¨ return error CommandOutput if blocks is empty
    if not blocks:
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Start marker '{marker_name_str}' not found in '{path_str}'.",
          summary=f"Failed to update marker in {path_str}: start marker not found."
      )
    # âœ¨
    # âœ¨ return error CommandOutput if blocks has more than one element
    if len(blocks) > 1:
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Multiple start markers named '{marker_name_str}' found in '{path_str}'. Marker names must be unique for updates.",
          summary=f"Failed to update marker in {path_str}: duplicate start marker names."
      )
    # âœ¨

    block: ExpandedMarker = blocks[0]

    marker_line = lines[block.start_index]
    marker_indentation = len(marker_line) - len(marker_line.lstrip())

    content_lines: list[str] = content.splitlines()

    # Conditionally remove start/end comments if they are in `content`:
    # âœ¨ conditionally remove marker start end from content
    file_extension = _get_file_extension(path)
    expected_start_marker = comment_string(file_extension, f"âœ¨ {marker_name_str}")
    expected_end_marker = comment_string(file_extension, "âœ¨")

    if content_lines and len(content_lines) >= 2:
      if (content_lines[0].strip() == expected_start_marker.strip() and
          content_lines[-1].strip() == expected_end_marker.strip()):
        content_lines = content_lines[1:-1]
    # âœ¨

    indented_content = reindent_code("\n".join(content_lines),
                                     marker_indentation)

    new_lines = []
    new_lines.extend(lines[:block.start_index + 1])
    new_lines.append(indented_content)
    new_lines.extend(lines[block.end_index:])

    new_file_content = "\n".join(new_lines)

    try:
      async with aiofiles.open(path, mode='w') as f:
        await f.write(new_file_content)
      if self._validation_manager:
        self._validation_manager.RegisterChange()
      # âœ¨ return success CommandOutput
      return CommandOutput(
          command_name=self.Name(),
          output=f"Successfully updated marker '{marker_name_str}' in '{path_str}'.",
          errors="",
          summary=f"Updated marker '{marker_name_str}' in '{path_str}'.")
      # âœ¨
    except Exception as e:
      # âœ¨ return error CommandOutput exception
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Error writing to {path_str}: {str(e)}",
          summary=f"{self.Name()} command encountered an error.")
      # âœ¨