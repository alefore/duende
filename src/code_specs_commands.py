# DO NOT EDIT. This file is automatically generated by Duende.
# The default validator for expanding this file should be:
#
#     MYPYPATH=~/coding-agent/src mypy $DMPATH

import asyncio
import difflib
import logging
import os
import pathlib
import re
from typing import Any

import aiofiles

from agent_command import AgentCommand, Argument, ArgumentContentType, CommandOutput, CommandSyntax, REASON_VARIABLE, VariableMap, VariableName, VariableValue, VariableValueStr
from file_access_policy import FileAccessPolicy
from code_specs import comment_string, ExpandedMarker, FileExtension, get_expanded_markers, get_markers, MarkerChar, MarkerName, MarkersOverlapError, MarkerImplementation, reindent_code, RepeatedExpandedMarkersError
from validation import ValidationManager

_PATH_VARIABLE = VariableName("path")
_MARKER_NAME_VARIABLE = VariableName("marker_name")
_CONTENT_VARIABLE = VariableName("content")


def _get_file_extension(path: pathlib.Path) -> FileExtension:
  """Returns the file extension (sans the dot), handling `.dm.foo` files.

  {{ðŸ¦” Given 'foo.py', returns 'py'.}}
  {{ðŸ¦” Given 'src/foo.dm.py', returns 'py'.}}
  """
  # âœ¨ get file extension
  file_extension_str = path.suffix.lstrip('.')
  if '.dm.' in path.name:
    parts = path.name.split('.')
    try:
      dm_index = parts.index('dm')
      if dm_index + 1 < len(parts):
        file_extension_str = parts[dm_index + 1]
      else:
        file_extension_str = ''
    except ValueError:
      file_extension_str = path.suffix.lstrip('.')
  return FileExtension(file_extension_str)
  # âœ¨


class MarkerUpdateError(ValueError):
  pass


class ListDuendeMarkerImplementationCommand(AgentCommand):

  def __init__(self,
               file_access_policy: FileAccessPolicy,
               validation_manager: ValidationManager | None = None):
    self._file_access_policy = file_access_policy
    self._validation_manager = validation_manager

  def Name(self) -> str:
    return "list_duende_implementation_markers"

  def Syntax(self) -> CommandSyntax:
    return CommandSyntax(
        name=VariableName("list_duende_implementation_marker"),
        description="Lists all Duende implementation markers in a file.",
        arguments=[
            REASON_VARIABLE,
            Argument(
                name=_PATH_VARIABLE,
                arg_type=ArgumentContentType.PATH_INPUT_OUTPUT,
                description="The path of the file to list markers from."),
        ])

  async def run(self, inputs: VariableMap) -> CommandOutput:
    path = inputs[_PATH_VARIABLE]
    assert isinstance(path, pathlib.Path)
    try:
      blocks = get_expanded_markers(path)
    except FileNotFoundError as e:
      # âœ¨ list: return error output exception file not found
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"File not found: {path}",
          summary=f"Failed to list markers in {path}: file not found.")
      # âœ¨
    except RepeatedExpandedMarkersError as e:
      # âœ¨ list: return error output exception repeated markers
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Multiple markers found in {path}: {str(e)}",
          summary=f"Failed to list markers in {path}: multiple markers found.")
      # âœ¨
    # âœ¨ return output listing all blocks
    if not blocks:
      return CommandOutput(
          command_name=self.Name(),
          output=f"No Duende implementation markers found in '{path}'.",
          errors="",
          summary=f"No markers found in '{path}'.")
    else:
      output_lines = [
          f"Found {len(blocks)} Duende implementation markers in '{path}':"
      ]
      for block in blocks:
        # Line numbers are 1-indexed for display
        output_lines.append(
            f"  - Marker '{block.name}': lines {block.start_index + 1}-{block.end_index + 1}"
        )
      return CommandOutput(
          command_name=self.Name(),
          output="\n".join(output_lines),
          errors="",
          summary=f"Listed {len(blocks)} markers in '{path}'.")
    # âœ¨


class ReadDuendeImplementationMarkerCommand(AgentCommand):

  def __init__(self,
               file_access_policy: FileAccessPolicy,
               validation_manager: ValidationManager | None = None):
    self._file_access_policy = file_access_policy
    self._validation_manager = validation_manager

  def Name(self) -> str:
    return "read_duende_implementation_marker"

  def Syntax(self) -> CommandSyntax:
    return CommandSyntax(
        name=VariableName("read_duende_implementation_marker"),
        description="Reads a Duende implementation marker from a file.",
        arguments=[
            REASON_VARIABLE,
            Argument(
                name=_PATH_VARIABLE,
                arg_type=ArgumentContentType.PATH_INPUT_OUTPUT,
                description="The path of the file to read from."),
            Argument(
                name=_MARKER_NAME_VARIABLE,
                arg_type=ArgumentContentType.STRING,
                description="The name of the marker to read."),
        ],
        output_description="The entire contents of the marker.")

  async def run(self, inputs: VariableMap) -> CommandOutput:
    """Returns the contents of a given marker.

    {{ðŸ¦” If the marker is not found in the file, returns an error. The error
         includes the explicit list of all markers found in the file (or an
         explicit explanation if the file contains no markers.}}
    """
    path = inputs[_PATH_VARIABLE]
    assert isinstance(path, pathlib.Path)
    marker_name = inputs[_MARKER_NAME_VARIABLE]
    assert isinstance(marker_name, str)
    try:
      blocks = get_expanded_markers(path)
    except FileNotFoundError as e:
      # âœ¨ read: return error output exception file not found
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"File not found: {path}",
          summary=f"Failed to read marker '{marker_name}' in {path}: file not found."
      )
      # âœ¨
    except RepeatedExpandedMarkersError as e:
      # âœ¨ read: return error output exception repeated markers
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Multiple markers found in {path}: {str(e)}",
          summary=f"Failed to read marker '{marker_name}' in {path}: multiple markers found."
      )
      # âœ¨
    block = [b for b in blocks if b.name == marker_name]
    if not block:
      # âœ¨ read: raise if block is empty
      if not block:
        if not blocks:
          return CommandOutput(
              command_name=self.Name(),
              output="",
              errors=f"No Duende implementation markers found in '{path}'.",
              summary=f"Failed to read marker '{marker_name}' in '{path}': no markers found."
          )
        else:
          available_markers = [b.name for b in blocks]
          return CommandOutput(
              command_name=self.Name(),
              output="",
              errors=f"Marker '{marker_name}' not found in '{path}'. Available markers: {', '.join(available_markers)}",
              summary=f"Failed to read marker '{marker_name}' in '{path}': marker not found."
          )
      # âœ¨
    assert len(block) == 1
    # âœ¨ read: return contents from block[0]
    # The block object already contains the content string.
    return CommandOutput(
        command_name=self.Name(),
        output=block[0].contents,
        errors="",
        summary=f"Successfully read marker '{marker_name}' from '{path}'.")
    # âœ¨


class UpdateDuendeMarkerImplementationCommand(AgentCommand):

  def __init__(self,
               file_access_policy: FileAccessPolicy,
               validation_manager: ValidationManager | None = None):
    self._file_access_policy = file_access_policy
    self._validation_manager = validation_manager

  def Name(self) -> str:
    return "update_duende_marker_implementation"

  def Syntax(self) -> CommandSyntax:
    return CommandSyntax(
        name=VariableName("update_duende_marker_implementation"),
        description="Updates a Duende marker implementation block in a file.",
        arguments=[
            REASON_VARIABLE,
            Argument(
                name=_PATH_VARIABLE,
                arg_type=ArgumentContentType.PATH_INPUT_OUTPUT,
                description="The path of the file to update."),
            Argument(
                name=_MARKER_NAME_VARIABLE,
                arg_type=ArgumentContentType.STRING,
                description="The name of the marker to update."),
            Argument(
                name=_CONTENT_VARIABLE,
                arg_type=ArgumentContentType.STRING,
                description=(
                    "The new content for the marker implementation block. "
                    "This will replace all lines between the "
                    "\"âœ¨ {marker_name}\" comment "
                    "and the following \"âœ¨\" comment (in `path`)."))
        ],
        output_description="A string describing the result of the operation.")

  async def _get_updated_content(self, path: pathlib.Path, marker_name: str,
                                 content: str) -> str:
    """Loads contents from `path` and returns them replacing `marker_name`.

    {{ðŸ¦” Only reads `path`, does not modify it.}}
    {{ðŸ¦” Raises MarkerUpdateError on any invalid condition: marker is not found,
         file can't be read, marker is duplicated in the file.}}
    {{ðŸ¦” If the marker is not found, the `MarkerUpdateError` exception includes
         a list of all available markers.}}
    {{ðŸ¦” `content` may start with the marker-start comment but it doesn't
         need to. Correctly handles both cases (without repeating the
         marker-start comment in the output). Same for the marker-end comment.}}
    """
    try:
      async with aiofiles.open(path, mode='r') as f:
        lines = (await f.read()).splitlines()
    except Exception as e:
      # âœ¨ raise MarkerUpdateError: read
      raise MarkerUpdateError(f"Error reading file {path.name}: {str(e)}")
      # âœ¨

    all_blocks = get_expanded_markers(path)
    blocks = [m for m in all_blocks if m.name == marker_name]

    # âœ¨ raise MarkerUpdateError if blocks is empty
    if not blocks:
      # The docstring for _get_updated_content requires that if the marker
      # is not found, the MarkerUpdateError exception includes a list of all
      # available markers.
      # To fulfill that, we need to use the `all_blocks` variable that was
      # already retrieved.
      available_markers = [b.name for b in all_blocks]
      raise MarkerUpdateError(
          f"Marker '{marker_name}' not found in '{path.name}'. Available markers: {', '.join(available_markers)}"
      )
    # âœ¨
    # âœ¨ raise MarkerUpdateError if len(blocks) > 1
    if len(blocks) > 1:
      raise MarkerUpdateError(
          f"Multiple start markers named '{marker_name}' found in '{path.name}'. Marker names must be unique for updates."
      )
    # âœ¨

    block: ExpandedMarker = blocks[0]

    marker_line = lines[block.start_index]
    marker_indentation = len(marker_line) - len(marker_line.lstrip())

    content_lines: list[str] = content.splitlines()

    # Conditionally remove start/end comments if they are in `content`:
    # âœ¨ conditionally remove marker start from content
    file_extension = _get_file_extension(path)
    expected_start_marker = comment_string(file_extension, f"âœ¨ {marker_name}")
    if content_lines and content_lines[0].strip(
    ) == expected_start_marker.strip():
      content_lines = content_lines[1:]
    # âœ¨
    # âœ¨ conditionally remove marker end from content
    file_extension = _get_file_extension(path)
    expected_end_marker = comment_string(file_extension, "âœ¨")
    if content_lines and content_lines[-1].strip() == expected_end_marker.strip(
    ):
      content_lines = content_lines[:-1]
    # âœ¨

    indented_content = reindent_code("\n".join(content_lines),
                                     marker_indentation)

    new_lines = []
    new_lines.extend(lines[:block.start_index + 1])
    new_lines.append(indented_content)
    new_lines.extend(lines[block.end_index:])

    return "".join(f"{l}\n" for l in new_lines)

  async def _get_full_diff(self, path: pathlib.Path,
                           new_content: str) -> list[str] | None:
    if not await asyncio.to_thread(os.path.exists, path):
      return None

    async with aiofiles.open(path, "r") as f:
      original_content_lines: list[str] = (await f.read()).splitlines()
    return list(
        difflib.unified_diff(
            original_content_lines,
            new_content.splitlines(),
            fromfile=f"a/{path}",
            tofile=f"b/{path}",
            lineterm="",
        ))

  async def derive_args(self, inputs: VariableMap) -> VariableMap:
    output = VariableMap({})
    path = pathlib.Path(str(inputs[_PATH_VARIABLE]))
    marker_name = inputs[_MARKER_NAME_VARIABLE]
    assert isinstance(marker_name, str)
    content = inputs[_CONTENT_VARIABLE]
    assert isinstance(content, str)

    try:
      async with aiofiles.open(path, mode='r') as f:
        lines = (await f.read()).splitlines()
      updated_content = await self._get_updated_content(path, marker_name,
                                                        content)
      output[VariableName("content_diff")] = await self._derive_diff(
          path, VariableValueStr(updated_content))
    except Exception as e:
      pass
    return output

  async def _derive_diff(self, path: pathlib.Path,
                         new_content: VariableValueStr) -> VariableValue:
    try:
      diff = await self._get_full_diff(path, new_content)
      if diff is None:
        return VariableValueStr("File is new.")
      elif not diff:
        return VariableValueStr("No changes.")
      else:
        return VariableValueStr("\n".join(diff))
    except Exception as e:
      return VariableValueStr(f"Could not compute diff: {e}")

  async def run(self, inputs: VariableMap) -> CommandOutput:
    path_str = str(inputs[_PATH_VARIABLE])
    marker_name = str(inputs[_MARKER_NAME_VARIABLE])
    content = str(_CONTENT_VARIABLE)

    path = pathlib.Path(path_str)

    if not self._file_access_policy.allow_access(path_str):
      # âœ¨ return error CommandOutput policy
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"File access denied for writing to {path_str}.",
          summary=f"Failed to update marker in {path_str}: access denied.")
      # âœ¨

    try:
      async with aiofiles.open(path, mode='w') as f:
        await f.write(await self._get_updated_content(path, marker_name,
                                                      content))
      if self._validation_manager:
        self._validation_manager.RegisterChange()
      # âœ¨ return success CommandOutput
      return CommandOutput(
          command_name=self.Name(),
          output=f"Successfully updated marker '{marker_name}' in '{path_str}'.",
          errors="",
          summary=f"Updated marker '{marker_name}' in '{path_str}'.")
      # âœ¨
    except Exception as e:
      # âœ¨ return error CommandOutput exception
      return CommandOutput(
          command_name=self.Name(),
          output="",
          errors=f"Error writing to {path_str}: {str(e)}",
          summary=f"{self.Name()} command encountered an error.")
      # âœ¨
