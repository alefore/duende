# DO NOT EDIT. This file is automatically generated by Duende.
import aiofiles
import asyncio
import dataclasses
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_loop_options import BaseAgentLoopFactory
from agent_workflow import AgentWorkflow, AgentWorkflowFactory
from agent_workflow_options import AgentWorkflowOptions
from code_specs import FileExtension, MarkerChar, MarkerImplementation, MarkerName, PathAndValidator, Validator, comment_string, get_markers, prepare_command_registry, prepare_initial_message, run_agent_loop
from conversation import Conversation, ConversationId, ConversationFactory
from conversation_state import ConversationState
from done_command import DoneCommand, DoneValuesValidator
from list_files_command import ListFilesCommand
from message import Message, ContentSection
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

# A token like "{{" + HEDGEHOG + " " + description + "}}" defines a property for
# which a unit test should be written (validating that the property holds).
HEDGEHOG = MarkerChar("ðŸ¦”")

MUSHROOM = MarkerChar("ðŸ„")

TestName = NewType("TestName", str)


@dataclasses.dataclass(frozen=True)
class TestMetadata:
  # The `description` string in the HEDGEHOG marker.
  property: str
  # A valid name for the test.
  name: TestName


@dataclasses.dataclass(frozen=True)
class TestImplementation:
  metadata: TestMetadata
  code: str


# Path to a file that contains `HEDGEHOG` markers describing properties that we
# want to test.
path_to_test_variable = VariableName('path_to_tests')

tests_skeleton_variable = VariableName('tests_skeleton')


def _list_tests(tests_path: pathlib.Path) -> list[TestName]:
  """Uses pytest to return a list of all the tests defined in tests_path."""
  # âœ¨ list tests
  result = subprocess.run(['pytest', '--collect-only', '-q',
                           str(tests_path)],
                          capture_output=True,
                          text=True,
                          check=False)

  if result.returncode != 0:
    # Handle cases where pytest might fail, e.g., syntax errors in test_path
    logging.error(f"pytest failed: {result.stderr}")
    return []

  test_names = []
  for line in result.stdout.splitlines():
    # Example line: "path/to/my_tests.py::test_function_name"
    # We want "test_function_name"
    match = re.search(r'::(test_[a-zA-Z0-9_]+)$', line)
    if match:
      test_names.append(TestName(match.group(1)))
  return test_names
  # âœ¨


class CodeSpecsTestsSkeletonWorkflow(AgentWorkflow):
  """Turns a DM file with HEDGEHOG markers into a DM file for the tests."""

  def __init__(self, options: AgentWorkflowOptions) -> None:
    self._options = options

  async def run(self) -> None:
    input = await self._get_initial_parameters()
    await self._prepare_tests_skeleton(input)

  async def _get_initial_parameters(self) -> pathlib.Path:
    """Obtains the path to test.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `path_to_test_variable`.}}
    """

    async def done_validator(inputs: VariableMap) -> ValidationResult:
      """Validates that path_to_test points to a correct path.

      {{ðŸ¦” Validation fails if the file can't be read.}}
      {{ðŸ¦” Validation fails if the file doesn't contain any HEDGEHOG markers
           (per `code_specs.get_markers`).}}
      {{ðŸ¦” Validation succeeds if the file can be read and contains HEDGEHOG
           markers (per `code_specs.get_markers`).}}
      """
      # âœ¨ initial parameters validator
      path_to_test_val = inputs.get(path_to_test_variable)
      if path_to_test_val is None:
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(path_to_test_variable) + "' is missing.")

      if not isinstance(path_to_test_val, (str, pathlib.Path)):
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(path_to_test_variable) +
            "' must be a string or a Path.")

      path_to_test = pathlib.Path(path_to_test_val)

      try:
        # Attempt to read the file to check if it exists and is readable
        async with aiofiles.open(path_to_test, mode="r") as f:
          await f.read()
      except FileNotFoundError:
        return ValidationResult(
            success=False,
            output="",
            error="File not found: " + str(path_to_test))
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error="Could not read file '" + str(path_to_test) + "': " + str(e))

      try:
        markers = await get_markers(char=HEDGEHOG, path=path_to_test)
        if not markers:
          return ValidationResult(
              success=False,
              output="",
              error="File '" + str(path_to_test) +
              "' contains no HEDGEHOG markers.")
      except ValueError as e:
        # This handles repeated markers, which `get_markers` raises as ValueError
        return ValidationResult(success=False, output="", error=str(e))
      except Exception as e:
        # Catch any other unexpected errors during marker extraction
        return ValidationResult(
            success=False,
            output="",
            error="Error processing markers in file '" + str(path_to_test) +
            "': " + str(e))

      return ValidationResult(
          success=True,
          output="File '" + str(path_to_test) + "' is valid.",
          error="")
      # âœ¨

    start_message_content = (
        "GOAL: Ask the user (through text conversation) "
        "for approprivate values "
        "for the variables expected by `done`. "
        "Describe these variables to the user "
        "to help them understand what is expected."
        "\n"
        "If the user mentions a file that doesn't exist, "
        "try to look for likely typos in their input. "
        "Try also to list files in the directory "
        "to see if you can guess what the user may have meant."
        "\n"
        "Once the user has given you appropriate values, "
        "your goal is achieved and you should run `done`.")
    # âœ¨ initial parameters
    command_registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                name=path_to_test_variable,
                arg_type=ArgumentContentType.PATH_INPUT,
                description="Path to the file containing HEDGEHOG markers for tests."
            )
        ],
        done_validator_callback=done_validator,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files=[],
    )

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="Get initial parameters",
        start_message=start_message,
        command_registry=command_registry,
    )

    path_to_test_val = output_variables.get(path_to_test_variable)
    if not isinstance(path_to_test_val, pathlib.Path):
      # This case should ideally be caught by the done_validator,
      # but as a safeguard, convert if it's a string, or raise if it's unexpected.
      if isinstance(path_to_test_val, str):
        return pathlib.Path(path_to_test_val)
      raise ValueError(
          f"Expected a Path for '{path_to_test_variable}', but got '{type(path_to_test_val)}'"
      )
    return path_to_test_val
    # âœ¨

  async def _prepare_tests_skeleton(self, input: pathlib.Path) -> None:
    """Runs an AgentLoop to create a skeleton for the tests.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `path_to_test_variable`.}}
    {{ðŸ¦” After validating that the skeleton contains all tests, writes them to
         a `tests_â€¦` file (e.g., for `src/foo.py`, writes `src/test_foo.py`).}}
    """
    start_message_content = (
        f"GOAL: Prepare a skeleton file for unit tests "
        f"based on the contents of file \"{input}\". "
        f"This file contains markers that look like this: "
        f"\"{{{HEDGEHOG} property to validate}}\" "
        f"(where \"property to validate\" is a description "
        f"of what the test should do). "
        f"Your skeleton should contain a unit test "
        f"for each of these markers, something like this:"
        f"\n\n"
        f"    await def test_foo_bar_name_here(self) -> None:\n"
        f"      pass  # {{{MUSHROOM} property to validate}}\n"
        f"\n"
        f"(The `await` keyword may not be necessary, "
        f"in which case it should be omitted; "
        f"the tests should be in a subclass either of `unittest.TestCase` "
        f"or `unittest.IsolatedAsyncioTestCase`)."
        f"\n"
        f"Please try to pick meaningful names for the tests "
        f"(as in the example `test_foo_bar_name_here`) based on both "
        f"(1) the text inside the curly braces (after the \"{HEDGEHOG}\", "
        f"and (2) the context around the line where the token occurs "
        f"(for example, if the token is given in a function's docstring, "
        f"it's very likely that it refers to tests for that function)."
        f"\n"
        f"As you can see, you are not actually going to implement the tests, "
        f"but you're just laying down the foundation. "
        f"We are turning the {{{HEDGEHOG} â€¦}} markers "
        f"into {{{MUSHROOM} â€¦}} markers, "
        f"which will drive the implementation of the tests."
        f"\n"
        f"Make sure to include this at the end of the file:"
        f"\n"
        f"\n"
        f"    if __name__ == '__main__':\n"
        f"      unittest.main()\n"
        f"\n"
        f"Once you're done, run `done`, "
        f"passing the entirety of the skeleton "
        f"as parameter {tests_skeleton_variable}.")

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Validates that tests_skeleton_variable has the right markers.

      Fails if the set of markers given in tests_skeleton_variable (per
      `code_spec.get_markers(MUSHROOM, output)` doesn't match the set of in
      `code_spec.get_markers(HEDGEHOG, input)`.
      """
      # âœ¨ tests skeleton validator
      path_to_test_val = inputs.get(path_to_test_variable)
      tests_skeleton_val = inputs.get(tests_skeleton_variable)

      if path_to_test_val is None:
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(path_to_test_variable) + "' is missing.")
      if not isinstance(path_to_test_val, (str, pathlib.Path)):
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(path_to_test_variable) +
            "' must be a string or a Path.")
      input_path = pathlib.Path(path_to_test_val)

      if tests_skeleton_val is None:
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(tests_skeleton_variable) + "' is missing.")
      if not isinstance(tests_skeleton_val, str):
        return ValidationResult(
            success=False,
            output="",
            error="Variable '" + str(tests_skeleton_variable) +
            "' must be a string.")
      skeleton_content = tests_skeleton_val

      # Get HEDGEHOG markers from the input file
      try:
        hedgehog_markers = await get_markers(char=HEDGEHOG, path=input_path)
      except FileNotFoundError:
        return ValidationResult(
            success=False,
            output="",
            error="Input file not found: " + str(input_path))
      except ValueError as e:
        return ValidationResult(
            success=False,
            output="",
            error="Error processing HEDGEHOG markers in input file: " + str(e))
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error="Unexpected error reading input file markers: " + str(e))

      # Get MUSHROOM markers from the skeleton content (using a temporary file)
      temp_dir = None
      try:
        temp_dir = pathlib.Path(tempfile.mkdtemp())
        temp_skeleton_path = temp_dir / "temp_skeleton.py"  # Assuming python for now, extension might not matter for get_markers

        async with aiofiles.open(temp_skeleton_path, mode="w") as f:
          await f.write(skeleton_content)

        mushroom_markers = await get_markers(
            char=MUSHROOM, path=temp_skeleton_path)
      except ValueError as e:
        return ValidationResult(
            success=False,
            output="",
            error="Error processing MUSHROOM markers in skeleton: " + str(e))
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error="Unexpected error processing skeleton markers: " + str(e))
      finally:
        if temp_dir and temp_dir.exists():
          shutil.rmtree(temp_dir)

      # Compare the marker names
      expected_marker_names = {marker.name for marker in hedgehog_markers}
      found_marker_names = {marker.name for marker in mushroom_markers}

      if expected_marker_names != found_marker_names:
        missing_markers = expected_marker_names - found_marker_names
        extra_markers = found_marker_names - expected_marker_names

        error_messages = []
        if missing_markers:
          error_messages.append(
              f"Missing MUSHROOM markers for: {', '.join(sorted(missing_markers))}."
          )
        if extra_markers:
          error_messages.append(
              f"Unexpected MUSHROOM markers found: {', '.join(sorted(extra_markers))}."
          )

        return ValidationResult(
            success=False,
            output="",
            error="Marker mismatch between input and skeleton. " +
            " ".join(error_messages))

      return ValidationResult(
          success=True,
          output="Tests skeleton markers match input markers.",
          error="")
      # âœ¨

    # âœ¨ prepare tests skeleton
    command_registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                name=tests_skeleton_variable,
                arg_type=ArgumentContentType.STRING,
                description="The complete test skeleton content.")
        ],
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files=[input],  # Pass the input file as relevant context
    )

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="Prepare tests skeleton",
        start_message=start_message,
        command_registry=command_registry,
    )

    tests_skeleton_content = output_variables.get(tests_skeleton_variable)
    if not isinstance(tests_skeleton_content, str):
      raise ValueError(
          f"Expected a string for '{tests_skeleton_variable}', but got '{type(tests_skeleton_content)}'"
      )

    # Determine the output file path (e.g., src/foo.py -> src/test_foo.py)
    output_filename = f"test_{input.name}"
    output_path = input.parent / output_filename

    async with aiofiles.open(output_path, mode="w") as f:
      await f.write(tests_skeleton_content)
    # âœ¨


class CodeSpecsTestsSkeletonWorkflowFactory(AgentWorkflowFactory):

  def name(self) -> str:
    return "dm-tests"

  async def new(self, agent_workflow_options: AgentWorkflowOptions,
                args: dict[str, str]) -> AgentWorkflow:
    return CodeSpecsTestsSkeletonWorkflow(agent_workflow_options)
