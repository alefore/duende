# DO NOT EDIT. This file is automatically generated by Duende.
import aiofiles
import asyncio
import dataclasses
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_loop_options import BaseAgentLoopFactory
from agent_workflow import AgentWorkflow, AgentWorkflowFactory
from agent_workflow_options import AgentWorkflowOptions
from code_specs import FileExtension, MarkerChar, MarkerImplementation, MarkerName, MarkersOverlapError, PathAndValidator, Validator, comment_string, get_markers, prepare_command_registry, prepare_initial_message, run_agent_loop
from conversation import Conversation, ConversationId, ConversationFactory
from conversation_state import ConversationState
from done_command import DoneCommand, DoneValuesValidator
from list_files_command import ListFilesCommand
from message import Message, ContentSection
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

# A token like "{{" + HEDGEHOG + " " + description + "}}" defines a property for
# which a unit test should be written (validating that the property holds).
HEDGEHOG = MarkerChar("ðŸ¦”")

MUSHROOM = MarkerChar("ðŸ„")

TestName = NewType("TestName", str)

# Path to a file that contains `HEDGEHOG` markers describing properties that we
# want to test.
path_to_test_variable = VariableName('path_to_test')

tests_skeleton_variable = VariableName('tests_skeleton')


class CodeSpecsTestsSkeletonWorkflow(AgentWorkflow):
  """Turns a DM file with HEDGEHOG markers into a DM file for the tests."""

  def __init__(self, options: AgentWorkflowOptions) -> None:
    self._options = options

  async def run(self) -> None:
    input = await self._get_initial_parameters()
    await self._prepare_tests_skeleton(input)

  async def _get_initial_parameters(self) -> pathlib.Path:
    """Obtains the path to test.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `path_to_test_variable`.}}
    """

    async def done_validator(inputs: VariableMap) -> ValidationResult:
      """Validates that path_to_test points to a correct path.

      {{ðŸ¦” Validation fails if the file can't be read.}}
      {{ðŸ¦” Validation fails if the file doesn't contain any HEDGEHOG markers
           (per `code_specs.get_markers`).}}
      {{ðŸ¦” Validation succeeds if the file can be read and contains HEDGEHOG
           markers (per `code_specs.get_markers`).}}
      {{ðŸ¦” Validation succeeds if the file contains repeated (identical)
           HEDGEHOG markers (per `code_specs.get_markers`).}}
      {{ðŸ¦” Does not require any variables other than `path_to_test_variable`.}}
      """
      # âœ¨ initial parameters validator
      path_to_test_value = inputs.get(path_to_test_variable)
      if not path_to_test_value:
        return ValidationResult(
            success=False,
            output="",
            error=f"'{path_to_test_variable}' is required and cannot be empty.")

      # Ensure path_to_test_value is treated as a path. It might come as a string.
      path = pathlib.Path(str(path_to_test_value))

      try:
        # Attempt to read the file and get markers.
        # This will also catch FileNotFoundError if the file doesn't exist.
        markers = await get_markers(HEDGEHOG, path)

        if not markers:
          return ValidationResult(
              success=False,
              output="",
              error=f"File '{path}' does not contain any '{HEDGEHOG}' markers.")

        # Per requirement: "Validation succeeds if the file contains repeated (identical) HEDGEHOG markers"
        # The get_markers function stores all positions for a given marker name.
        # If get_markers successfully returns, it means there are no overlaps (MarkersOverlapError is caught).
        # The presence of repeated *identical* HEDGEHOG markers does not lead to a validation failure here,
        # which aligns with the requirement.

      except FileNotFoundError:
        return ValidationResult(
            success=False,
            output="",
            error=f"File '{path}' not found or inaccessible.")
      except MarkersOverlapError as e:
          # Overlapping markers indicate a structural issue, which should result in failure.
          return ValidationResult(
              success=False,
              output="",
              error=f"File '{path}' contains overlapping '{HEDGEHOG}' markers: {e}")
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"An unexpected error occurred while validating file '{path}': {e}")

      return ValidationResult(
          success=True, output="Path to test is valid.", error="")
      # âœ¨

    start_message_content = (
        "GOAL: Ask the user (through text conversation) "
        "for approprivate values "
        "for the variables expected by `done`. "
        "Describe these variables to the user "
        "to help them understand what is expected."
        "\n"
        "If the user mentions a file that doesn't exist, "
        "try to look for likely typos in their input. "
        "Try also to list files in the directory "
        "to see if you can guess what the user may have meant."
        "\n"
        "Once the user has given you appropriate values, "
        "your goal is achieved and you should run `done`.")
    # âœ¨ initial parameters
    done_command_arguments = [
        Argument(
            name=path_to_test_variable,
            arg_type=ArgumentContentType.PATH_INPUT,
            description="Path to the file containing HEDGEHOG markers to be tested.",
            required=True,
        )
    ]

    command_registry = await prepare_command_registry(
        done_command_arguments=done_command_arguments,
        done_validator_callback=done_validator,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content, relevant_files=set()
    )

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="initial_parameters",
        start_message=start_message,
        command_registry=command_registry,
    )

    path_to_test = output_variables[path_to_test_variable]
    return pathlib.Path(str(path_to_test))
    # âœ¨

  async def _prepare_tests_skeleton(self, input: pathlib.Path) -> None:
    """Runs an AgentLoop to create a skeleton for the tests.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `tests_skeleton_variable`.}}
    {{ðŸ¦” After validating that the skeleton contains all tests, writes them to
         a `tests_â€¦` file (e.g., when `input` is `src/foo.py`, writes
         `src/test_foo.py`).}}
    {{ðŸ¦” `input` is passed as a relevant file to `prepare_initial_message`.'}}
    """
    start_message_content = (
        f"GOAL: Prepare a skeleton file for unit tests "
        f"based on the contents of file \"{input}\". "
        f"This file contains markers that look like this: "
        f"\"{{{{{HEDGEHOG} property to validate}}}}\" "
        f"(where \"property to validate\" is a description "
        f"of what the test should do). "
        f"Your skeleton should contain a unit test "
        f"for each of these markers, something like this:"
        f"\n\n"
        f"    await def test_foo_bar_name_here(self) -> None:\n"
        f"      pass  # {{{{{MUSHROOM} property to validate}}}}\n"
        f"\n"
        f"(The `await` keyword may not be necessary, "
        f"in which case it should be omitted; "
        f"the tests should be in a subclass either of `unittest.TestCase` "
        f"or `unittest.IsolatedAsyncioTestCase`)."
        f"\n"
        f"As you can see, you are not actually going to implement the tests, "
        f"but you're just laying down the foundation. "
        f"We are turning the {{{{{HEDGEHOG} â€¦}}}} markers "
        f"into {{{{{MUSHROOM} â€¦}}}} markers, "
        f"which will drive the implementation of the tests."
        f"\n"
        f"The input file may contain repeated {{{{{HEDGEHOG} â€¦}}}} markers; "
        f"for example, multiple functions may share an identical property. "
        f"However, {{{{{MUSHROOM} â€¦}}}} markers "
        f"must be identical in the output. "
        f"That means that if you find repeated {HEDGEHOG} markers, "
        f"you must add more information inside the output markers "
        f"in order to disambiguate them."
        f"\n"
        f"Please try to pick meaningful names for the tests "
        f"(as in the example `test_foo_bar_name_here`) based on both "
        f"(1) the text inside the curly braces (after the \"{HEDGEHOG}\", "
        f"and (2) the context around the line where the token occurs "
        f"(for example, if the token is given in a function's docstring, "
        f"it's very likely that it refers to tests for that function)."
        f"\n"
        f"Make sure to include this at the end of the file:"
        f"\n"
        f"\n"
        f"    if __name__ == '__main__':\n"
        f"      unittest.main()\n"
        f"\n"
        f"Once you're done, run `done`, "
        f"passing the entirety of the skeleton "
        f"as parameter {tests_skeleton_variable}.")

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Validates that tests_skeleton_variable has the right markers.


      {{ðŸ¦” Fails if the set of markers given in tests_skeleton_variable is
           rejected by `code_spec.get_markers(MUSHROOM, output)`.}}
      {{ðŸ¦” Fails if an identical marker (in the value of
           `tests_skeleton_variable`) is repeated (more than one location, per
           `code_spec.get_markers(MUSHROOM, output)`).}}
      {{ðŸ¦” Fails if the number of HEDGEHOG markers in the input isn't exactly
           the same as the number of MUSHROOM markers in the output.}}
      {{ðŸ¦” Does not require any variables beyond `tests_skeleton_variable`.}}
      """
      # âœ¨ tests skeleton validator
      tests_skeleton_value = inputs.get(tests_skeleton_variable)
      if not tests_skeleton_value:
        return ValidationResult(
            success=False,
            output="",
            error=f"'{tests_skeleton_variable}' is required and cannot be empty.")

      skeleton_content = str(tests_skeleton_value)

      # Get HEDGEHOG markers from the input file
      try:
        # 'input' is captured from the enclosing scope and is a pathlib.Path
        hedgehog_markers_map = await get_markers(HEDGEHOG, input)
        total_hedgehog_markers = sum(len(locations) for locations in hedgehog_markers_map.values())
      except MarkersOverlapError as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"Input file '{input}' contains overlapping '{HEDGEHOG}' markers: {e}")
      except FileNotFoundError:
        return ValidationResult(
            success=False,
            output="",
            error=f"Input file '{input}' not found or inaccessible while validating skeleton.")
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"An unexpected error occurred while processing input file '{input}': {e}")

      # Get MUSHROOM markers from the generated skeleton content
      # If mypy expects Path, write skeleton_content to a temporary file
      # and pass the path to get_markers.
      temp_dir = None
      temp_file_path = None
      try:
        temp_dir = tempfile.mkdtemp()
        temp_file_path = pathlib.Path(temp_dir) / "temp_skeleton_file.py"
        async with aiofiles.open(temp_file_path, mode="w") as f:
            await f.write(skeleton_content)

        mushroom_markers_map = await get_markers(MUSHROOM, temp_file_path)
        total_mushroom_markers = sum(len(locations) for locations in mushroom_markers_map.values())
      except MarkersOverlapError as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"Generated skeleton contains overlapping '{MUSHROOM}' markers: {e}")
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"An unexpected error occurred while processing the generated skeleton: {e}")
      finally:
        if temp_dir and pathlib.Path(temp_dir).exists():
            shutil.rmtree(temp_dir) # Clean up temporary directory

      # Fails if an identical MUSHROOM marker (content) is repeated.
      for marker_name, implementations in mushroom_markers_map.items():
        if len(implementations) > 1:
          return ValidationResult(
              success=False,
              output="",
              error=f"MUSHROOM marker content '{{{MUSHROOM} {marker_name}}}' is repeated {len(implementations)} times in the skeleton. All MUSHROOM marker contents must be unique for disambiguation.")

      # Fails if the number of HEDGEHOG markers in the input isn't exactly
      # the same as the number of MUSHROOM markers in the output.
      if total_hedgehog_markers != total_mushroom_markers:
        return ValidationResult(
            success=False,
            output="",
            error=f"Mismatch in marker counts: Input has {total_hedgehog_markers} '{HEDGEHOG}' markers, but skeleton has {total_mushroom_markers} '{MUSHROOM}' markers. Counts must be equal.")

      return ValidationResult(
          success=True, output="Tests skeleton is valid.", error="")
      # âœ¨

    # âœ¨ prepare tests skeleton
    done_command_arguments = [
        Argument(
            name=tests_skeleton_variable,
            arg_type=ArgumentContentType.STRING,  # The skeleton is a string of code
            description="The complete skeleton code for the unit tests.",
            required=True,
        )
    ]

    relevant_files_for_message = {input}

    command_registry = await prepare_command_registry(
        done_command_arguments=done_command_arguments,
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files=relevant_files_for_message,
    )

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="prepare_tests_skeleton",
        start_message=start_message,
        command_registry=command_registry,
    )

    tests_skeleton = output_variables[tests_skeleton_variable]

    # Construct the output file path.
    # If input is 'src/foo.py', output should be 'src/test_foo.py'.
    # If input is 'src/foo.dm.py', it should be 'src/test_foo.py'
    input_stem = input.stem
    if ".dm" in input_stem:
      input_stem = input_stem.replace(".dm", "")
    output_file_name = f"test_{input_stem}{input.suffix}"
    output_path = input.parent / output_file_name

    # Write the skeleton to the target file.
    async with aiofiles.open(output_path, mode="w") as f:
      await f.write(str(tests_skeleton))
    # âœ¨


class CodeSpecsTestsSkeletonWorkflowFactory(AgentWorkflowFactory):

  def name(self) -> str:
    return "dm-tests"

  async def new(self, agent_workflow_options: AgentWorkflowOptions,
                args: dict[str, str]) -> AgentWorkflow:
    return CodeSpecsTestsSkeletonWorkflow(agent_workflow_options)