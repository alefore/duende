# DO NOT EDIT. This file is automatically generated by Duende.
"""Implementation of workflow to implement DM markers per doc/code-specs.md."""

import aiofiles
import asyncio
import dataclasses
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_loop_options import BaseAgentLoopFactory
from agent_workflow import AgentWorkflow, AgentWorkflowFactory
from agent_workflow_options import AgentWorkflowOptions
from code_specs import FileExtension, MarkerChar, MarkerImplementation, MarkerName, PathAndValidator, Validator, comment_string, get_markers, prepare_command_registry, prepare_initial_message, relevant_paths_variable, run_agent_loop
from conversation import Conversation, ConversationId, ConversationFactory
from conversation_state import ConversationState
from done_command import DoneCommand, DoneValuesValidator
from list_files_command import ListFilesCommand
from message import Message, ContentSection
import output_cache
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

MUSHROOM = MarkerChar("ðŸ„")

# If the end user specifies files with globs (e.g., `src/bar/*/age*/fo*.py`),
# the conversational AI should try to search for it and help the user.
dm_path_variable = VariableName('dm_path')

validator_variable = VariableName('validator')

# Value is a block of code that implement a DM marker. See MarkerImplementation
# for constraints on allowed values.
implementation_variable = VariableName('implementation')


class CodeSpecsWorkflow(AgentWorkflow):

  def __init__(self, options: AgentWorkflowOptions) -> None:
    self._options = options
    self._output_cache = output_cache.OutputCache(output_cache.DEFAULT_PATH)

  async def run(self) -> None:
    input = await self._get_initial_parameters()
    await self._prepare_output_path(input)
    relevant_paths = await self._find_relevant_paths(input.output_path())
    await self._implement_file(input, relevant_paths)

  async def _get_initial_parameters(self) -> PathAndValidator:
    """Obtains values to initialize a PathAndValidator.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`.

    {{ðŸ¦” The done command arguments given to `prepare_command_registry` are
         `dm_path_variable` and `validator_variable`.}}
    {{ðŸ¦” Does *not* enable caching of conversations (through output_cache).}}
    """

    async def done_validator(inputs: VariableMap) -> ValidationResult:
      """Validates that a PathAndValidator can be created from `inputs`.

      On any failure, gives a very friendly and helpful explanation message to
      the AI.

      {{ðŸ¦” If the dm_path has repeated (identical) MUSHROOM markers (per
           `code_specs.get_markers`), validation fails with an explanation.}}
      {{ðŸ¦” Catches exceptions from PathAndValidator and turns them into a
           failed `ValidationResult`.}}
      """
      # âœ¨ initial parameters validator
      dm_path_val = inputs.get(dm_path_variable)
      validator_val = inputs.get(validator_variable)

      if not dm_path_val:
        return ValidationResult(
            success=False,
            output="",
            error=(f"'{dm_path_variable}' is missing. "
                   "Please provide a path to the DM file "
                   "(e.g., 'src/my_component.dm.py')."))
      if not validator_val:
        return ValidationResult(
            success=False,
            output="",
            error=(
                f"'{validator_variable}' is missing. "
                "Please provide a validator command (e.g., 'mypy $DMPATH')."))

      try:
        dm_path = pathlib.Path(str(dm_path_val))
        validator = Validator(command=str(validator_val))
        path_and_validator = PathAndValidator(
            dm_path=dm_path, validator=validator)
        await path_and_validator.validate_fields()
        return ValidationResult(
            success=True, output="Parameters are valid.", error="")
      except ValueError as e:
        # PathAndValidator.validate_fields can raise ValueError for:
        # - Missing '.dm.' in path
        # - No ðŸ„ markers found
        # - Repeated or overlapping ðŸ„ markers (MarkersOverlapError is a ValueError subclass)
        # - FileNotFoundError (re-raised as ValueError)
        return ValidationResult(
            success=False,
            output="",
            error=f"Invalid parameters for PathAndValidator: {e}")
      except Exception as e:
        # Catch any other unexpected exceptions.
        return ValidationResult(
            success=False,
            output="",
            error=(
                f"An unexpected error occurred during validation: {e}. "
                "Please ensure the dm_path is a valid file and the validator "
                "command is correctly formatted."))
      # âœ¨

    start_message_content = (
        "GOAL: Ask the user (through text conversation) for approprivate values "
        "for the variables expected by `done`. "
        "Describe these variables to the user "
        "to help them understand what is expected "
        "(mention the $DMPATH environment variable of `validator`)."
        "\n"
        "If the user mentions a file that doesn't exist, "
        "try to look for likely typos in their input. "
        "Try also to list files in the directory "
        "to see if you can guess what the user may have meant. "
        "Your goal is to figure out which file the user means "
        "even if the user is sloppy or lazy "
        "(maybe he is too busy; "
        "or is typing on a phone with broken autocomplete). "
        "Try to save the user time."
        "\n"
        "Once the user has mentioned a file, "
        "read it and try to see if the file suggests "
        "what to use as the validator for its own expansion, "
        "typically near the top of the file."
        "\n"
        "If the dm_path is a Python file, "
        "suggest that the validator could be `mypy` "
        "(with an appropriate MYPATH=\"â€¦\" value) "
        "or `python3` (with an appropriate PYTHONPATH=\"â€¦\" value)."
        "\n"
        "Once the user has given you appropriate values "
        "(or you have inferred them), "
        "your goal is achieved and you should run `done`.")
    # âœ¨ initial parameters
    registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                name=dm_path_variable,
                arg_type=ArgumentContentType.PATH_INPUT,
                description=(
                    "Path to the DM file "
                    "(e.g., 'src/my_component.dm.py'). "
                    "Must contain '.dm.' and at least one 'ðŸ„' marker.")),
            Argument(
                name=validator_variable,
                arg_type=ArgumentContentType.STRING,
                description=(
                    "A shell command that validates contents of a file. "
                    "The command receives the path through $DMPATH. "
                    "Example: 'mypy $DMPATH' or 'python3 -m pytest $DMPATH'. "
                    "If the dm_path is a Python file, "
                    "suggest that the validator could be `mypy` "
                    "(with an appropriate MYPATH=\"...\" value) "
                    "or `python3` (with an appropriate PYTHONPATH=\"...\" value)."
                )),
        ],
        done_validator_callback=done_validator,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files=set(),
    )

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="initial_parameters",
        start_message=start_message,
        command_registry=registry,
    )

    dm_path_val = output_variables.get(dm_path_variable)
    validator_val = output_variables.get(validator_variable)

    if not dm_path_val or not validator_val:
      # This case should ideally be caught by done_validator,
      # but as a safeguard, we raise an error.
      raise ValueError("Missing dm_path or validator in agent loop output.")

    return PathAndValidator(
        dm_path=pathlib.Path(str(dm_path_val)),
        validator=Validator(command=str(validator_val)),
    )
    # âœ¨

  async def _prepare_output_path(
      self, input: PathAndValidator) -> pathlib.Path | None:
    """Prepares various files, moving old implementations aside."""
    return_value: pathlib.Path | None = None
    if input.output_path().exists():
      # {{ðŸ¦” `input.output_path()` is copied to `input.output_path().old`
      #      (for example, `src/foo.py` becomes `src/foo.py.old`).}}
      # {{ðŸ¦” `return_value` is set to the location of the copy (`â€¦.old`).}}
      # âœ¨ prepare output paths if old output
      old_output_path = input.output_path().with_suffix('.old')
      shutil.copyfile(input.output_path(), old_output_path)
      return_value = old_output_path
      # âœ¨

    # {{ðŸ¦” Unconditionally overwrites `input.output_path()` with
    #   `input.dm_path` (after moving it to a temporary file).}}
    # âœ¨ prepare output path
    await input.overwrite(input.output_path())
    return return_value
    # âœ¨

  async def _find_relevant_paths(
      self, path: pathlib.Path) -> dict[MarkerName, set[pathlib.Path]]:
    """Finds all relevant markers.

    {{ðŸ¦” Calls `find_relevant_paths_for_marker` exactly once for each marker
         found in `path`.}}
    {{ðŸ¦” Calls to `find_relevant_paths_for_marker` happen concurrently.}}
    {{ðŸ¦” The output contains one entry for each marker found in `path`.}}
    {{ðŸ¦” The output values correspond to the outputs of
         `_find_relevant_paths_for_marker` for each key (marker).}}
    """
    # âœ¨ find relevant paths loop
    markers = await get_markers(MUSHROOM, path)
    tasks = []
    for marker_name in markers.keys():
      tasks.append(self._find_relevant_paths_for_marker(path, marker_name))

    results = await asyncio.gather(*tasks)

    relevant_paths_output: dict[MarkerName, set[pathlib.Path]] = {}
    for i, marker_name in enumerate(markers.keys()):
      relevant_paths_output[marker_name] = results[i]

    return relevant_paths_output
    # âœ¨

  async def _find_relevant_paths_for_marker(
      self, path: pathlib.Path, marker: MarkerName) -> set[pathlib.Path]:
    """Finds all relevant paths to implement a single DM marker.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`. The agent is focused exclusively on `marker`,
    with the goal of identifying the best value for `relevant_paths_variable`.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `relevant_paths_variable`.}}
    {{ðŸ¦” Enables caching of conversations: if two separate instances of
         CodeSpecsWorkflow have this method called with the same inputs,
         the 2nd call reuses the outputs from the first.}}
    """

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Verifies that all inputs[relevant_paths_variable] values are readable.

      {{ðŸ¦” If no files are given, validation fails, with a message that at least
           one relevant file should be given.}}
      {{ðŸ¦” All files must be readable (both by the OS as well as allowed by the
           `file_access_policy`). If one isn't, validation fails.}}
      {{ðŸ¦” If all files are readable (both by the OS and `file_access_policy`),
           validation succeeds.}}
      """
      # âœ¨ relevant paths validator
      relevant_paths_val = inputs.get(relevant_paths_variable)

      if not relevant_paths_val:
        return ValidationResult(
            success=False,
            output="",
            error=(f"'{relevant_paths_variable}' is missing. "
                   "Please provide at least one relevant file path "
                   "(e.g., 'src/foo.py,src/bar.cc')."))

      relevant_paths_str = str(relevant_paths_val)
      paths_list = [
          pathlib.Path(p.strip())
          for p in relevant_paths_str.split(',')
          if p.strip()
      ]

      if not paths_list:
        return ValidationResult(
            success=False,
            output="",
            error=(f"'{relevant_paths_variable}' is empty after parsing. "
                   "Please provide at least one relevant file path "
                   "(e.g., 'src/foo.py,src/bar.cc')."))

      file_access_policy = self._options.agent_loop_options.file_access_policy

      for p in paths_list:
        if not p.exists():
          return ValidationResult(
              success=False, output="", error=f"File '{p}' does not exist.")
        if not p.is_file():
          return ValidationResult(
              success=False, output="", error=f"Path '{p}' is not a file.")
        if not os.access(p, os.R_OK):
          return ValidationResult(
              success=False,
              output="",
              error=f"File '{p}' is not readable by the OS.")
        if not file_access_policy.allow_access(str(p)):
          return ValidationResult(
              success=False,
              output="",
              error=f"Access to file '{p}' is not allowed by the file access policy."
          )

      return ValidationResult(
          success=True,
          output="All relevant paths are valid and readable.",
          error="")
      # âœ¨

    start_message_content = (
        f"GOAL: identify local file paths that are relevant "
        f"to replace the line that contains '{{{{{MUSHROOM} {marker.name}}}}}' "
        f"from \"{path}\" (included below) with valid code."
        f"\n"
        f"These relevant paths should be given to the "
        f"`{relevant_paths_variable}` argument of the `done` command."
        f"\n"
        f"Example: `done(relevant_paths=\"src/foo.py,src/bar.cc\")"
        f"\n"
        f"Feel free to use `read_file`, `list_files` and `search_file` "
        f"to explore the codebase.")

    # Enable caching in the options given to `run_agent_loop`:
    options = self._options._replace(
        agent_loop_factory=output_cache.CachingDelegatingAgentLoopFactory(
            f"code_specs_workflow:{path}", self._output_cache,
            self._options.agent_loop_factory))
    # âœ¨ find relevant paths
    registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                name=relevant_paths_variable,
                arg_type=ArgumentContentType.PATH_UNVALIDATED,
                description=(
                    "Comma-separated list of local file paths that are relevant "
                    "to implement the DM marker. "
                    "Example: 'src/foo.py,src/bar.cc'.")),
        ],
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files={path},
    )

    output_variables = await run_agent_loop(
        workflow_options=options,
        conversation_name=f"find_relevant_paths_for_{marker.name}",
        start_message=start_message,
        command_registry=registry,
    )

    relevant_paths_str_val = output_variables.get(relevant_paths_variable)

    if not relevant_paths_str_val:
      raise ValueError(
          f"Missing {relevant_paths_variable} in agent loop output.")

    relevant_paths_str = str(relevant_paths_str_val)
    paths_list = {
        pathlib.Path(p.strip())
        for p in relevant_paths_str.split(',')
        if p.strip()
    }

    return paths_list
    # âœ¨

  async def _implement_file(
      self, inputs: PathAndValidator,
      relevant_paths: dict[MarkerName, set[pathlib.Path]]) -> None:
    """Implements all DM markers in `inputs.output_path()` sequentially.

    {{ðŸ¦” The calls to `_implement_marker` happen sequentially.}}
    {{ðŸ¦” The output of a call to `_implement_marker` is stored through
         `MarkerImplementation.save` on `inputs.output_path()`.}}
    {{ðŸ¦” The output of a call to `_implement_marker` is stored before the next
         call begins (so that the next call already sees the output of the
         previous call).}}
    {{ðŸ¦” The calls to `_implement_marker` happen in the order in which the
         markers occur in the DM file.}}
    """
    # âœ¨ implement file
    # Get all markers from the output_path (which is the modified dm_path without '.dm.')
    output_file_markers = await get_markers(MUSHROOM, inputs.output_path())

    for marker_name in output_file_markers:
      # Retrieve the relevant paths for the current marker
      # If no relevant paths were found for a specific marker, it will be an empty set
      marker_relevant_paths = relevant_paths.get(marker_name, set())

      # Call _implement_marker to get the implementation for the current marker
      implementation = await self._implement_marker(
          marker=marker_name,
          relevant_paths=marker_relevant_paths,
          validator=inputs.validator,
          output_path=inputs.output_path())

      # Save the implementation to update the output file before processing the next marker
      await implementation.save(inputs.output_path())
    # âœ¨

  async def _implement_marker(
      self, marker: MarkerName, relevant_paths: set[pathlib.Path],
      validator: Validator, output_path: pathlib.Path) -> MarkerImplementation:
    """Finds a suitable implementation for `marker` from `output_path`.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`. The agent is focused exclusively on `marker`,

    The AI outputs the implementation code to `done` through
    `implementation_variable`.

    {{ðŸ¦” For each file in `relevant_paths`, there's a section in the initial
         message (prompt) given to the AI.}}
    {{ðŸ¦” If `output_path + '.old'` exists, it gets included in the initial
         message (as if it had been included in `relevant_paths`.}}
    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `implementation_variable`.}}
    {{ðŸ¦” Enables caching of conversations: if two separate instances of
         CodeSpecsWorkflow have this method called for the same output_path and
         marker, the 2nd call reuses the outputs from the first.}}

    Arguments:
      marker: The marker to implement.
      relevant_paths: A list of relevant paths for the initial prompt.

      validator: The validator used to verify a plausible implementation.
      output_path: The input file with the context for implementing `marker`. We
        do not actually update it (our customer does).

    Returns:
      A validated MarkerImplementation that customers can call `save` on.
    """

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Calls validator.validate_marker_implementation to validate."""
      # âœ¨ implement validator
      implementation_val = inputs.get(implementation_variable)

      if not implementation_val:
        return ValidationResult(
            success=False,
            output="",
            error=(f"'{implementation_variable}' is missing. "
                   "Please provide the implementation code block."))

      try:
        implementation_obj = MarkerImplementation(
            name=marker,
            value=str(implementation_val),
            file_extension=file_extension)
        return await validator.validate_marker_implementation(
            source=output_path, implementation=implementation_obj)
      except ValueError as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"Invalid implementation block format: {e}")
      # âœ¨

    file_extension = FileExtension(output_path.suffix[1:])
    start_message_content = (
        "GOAL: provide the *code content* "
        "that will replace the line containing the "
        f"'{{{{{MUSHROOM} {marker.name}}}}}' marker "
        f"in the file '{output_path}'."
        "\n"
        "The implementation block *must* strictly follow this format:"
        "\n"
        "* It must begin with line containing nothing but "
        f"\"{comment_string(file_extension, 'âœ¨ ' + marker.name)}\" "
        "(preceded by whitespace characters to match "
        "the indentation of the block that contains the implementation)."
        "\n"
        "It must end with a line containing "
        f"nothing but \"{comment_string(file_extension, 'âœ¨')}\" "
        "(also preceded by whitespace)."
        "\n"
        "Once you have the complete and correct implementation code, "
        "call the `done` command. "
        f"The `done` command requires an argument `{implementation_variable}` "
        "which *must* be your full implementation block as a single string.")

    # Content to append *conditionally* if `output_path + '.old'` exists:
    additional_start_message_content_if_old_implementation_available = (
        f"In your implementation, try to reuse as much as possible any old "
        f"implementation (from the `{output_path}.old` file). "
        f"Only change the implementation if this is strictly necessary: "
        f"if the old implementation has bugs "
        f"(e.g., does not honor some documented property), "
        f"new requirements have been added, "
        f"or requirements have been removed/relaxed "
        f"(in ways that allow code simplifications).")

    # Enable caching in the options given to `run_agent_loop`:
    options = self._options._replace(
        agent_loop_factory=output_cache.CachingDelegatingAgentLoopFactory(
            f"code_specs_workflow:{output_path}", self._output_cache,
            self._options.agent_loop_factory))

    # âœ¨ implement single marker
    registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                name=implementation_variable,
                arg_type=ArgumentContentType.STRING,
                description=("The code content that will replace the marker. "
                             "It must be a complete and valid code block, "
                             "following the specified format.")),
        ],
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy,
    )

    all_relevant_files = set(relevant_paths)
    all_relevant_files.add(output_path)
    old_output_path = output_path.with_suffix('.old')
    if old_output_path.exists():
      all_relevant_files.add(old_output_path)
      start_message_content += (
          '\n' +
          additional_start_message_content_if_old_implementation_available)

    start_message = await prepare_initial_message(
        start_message_content=start_message_content,
        relevant_files=all_relevant_files,
    )

    output_variables = await run_agent_loop(
        workflow_options=options,
        conversation_name=f"implement_marker_{marker.name}",
        start_message=start_message,
        command_registry=registry,
    )

    implementation_str_val = output_variables.get(implementation_variable)

    if not implementation_str_val:
      raise ValueError(
          f"Missing {implementation_variable} in agent loop output.")

    return MarkerImplementation(
        name=marker,
        value=str(implementation_str_val),
        file_extension=file_extension,
    )
    # âœ¨


class CodeSpecsWorkflowFactory(AgentWorkflowFactory):

  def name(self) -> str:
    return "dm"

  async def new(self, agent_workflow_options: AgentWorkflowOptions,
                args: dict[str, str]) -> AgentWorkflow:
    return CodeSpecsWorkflow(agent_workflow_options)
