# DO NOT EDIT. This file is automatically generated by Duende.
"""Implementation of workflow to implement DM markers per doc/code-specs.md."""

import aiofiles
import asyncio
import dataclasses
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_loop_options import BaseAgentLoopFactory
from agent_workflow import AgentWorkflow, AgentWorkflowFactory
from agent_workflow_options import AgentWorkflowOptions
from code_specs import FileExtension, MarkerChar, MarkerImplementation, MarkerName, PathAndValidator, Validator, comment_string, get_markers, prepare_command_registry, prepare_initial_message, run_agent_loop
from conversation import Conversation, ConversationId, ConversationFactory
from conversation_state import ConversationState
from done_command import DoneCommand, DoneValuesValidator
from list_files_command import ListFilesCommand
from message import Message, ContentSection
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

MUSHROOM = MarkerChar("ðŸ„")

# If the end user specifies files with globs (e.g., `src/bar/*/age*/fo*.py`),
# the conversational AI should try to search for it and help the user.
dm_path_variable = VariableName('dm_path')

validator_variable = VariableName('validator')

# Value is a block of code that implement a DM marker. See MarkerImplementation
# for constraints on allowed values.
implementation_variable = VariableName('implementation')

# Value is a comma-separated list of local files that someone implementing a DM
# marker may want to read.
relevant_paths_variable = VariableName('relevant_paths')


class CodeSpecsWorkflow(AgentWorkflow):

  def __init__(self, options: AgentWorkflowOptions) -> None:
    self._options = options

  async def run(self) -> None:
    input = await self._get_initial_parameters()
    if not input.output_path().exists():
      await input.overwrite(input.output_path())
    relevant_paths = await self._find_relevant_paths(input.output_path())
    await self._implement_file(input, relevant_paths)

  async def _get_initial_parameters(self) -> PathAndValidator:
    """Obtains values to initialize a PathAndValidator.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`.

    {{ðŸ¦” The done command arguments given to `prepare_command_registry` are
         `dm_path_variable` and `validator_variable`.}}
    """

    async def done_validator(inputs: VariableMap) -> ValidationResult:
      """Validates that a PathAndValidator can be created from `inputs`.

      If PathAndValidator(â€¦) raises an exception, gives a friendly error
      message to the AI."""
      # âœ¨ initial parameters validator
      dm_path_value = inputs.get(dm_path_variable)
      validator_command_str = inputs.get(validator_variable)

      if not isinstance(dm_path_value, str):
        return ValidationResult(
            success=False,
            output="",
            error=f"The path for '{dm_path_variable}' must be a string.")
      if not isinstance(validator_command_str, str):
        return ValidationResult(
            success=False,
            output="",
            error=f"The validator command for '{validator_variable}' must be a string."
        )

      try:
        path_and_validator = PathAndValidator(
            dm_path=pathlib.Path(dm_path_value),
            validator=Validator(command=validator_command_str))
        await path_and_validator.validate_fields()
        return ValidationResult(
            success=True,
            output="Initial parameters validated successfully.",
            error="")
      except ValueError as e:
        return ValidationResult(
            success=False, output="", error=f"Validation failed: {e}")
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"An unexpected error occurred during validation: {e}. Please check the provided values."
        )
      # âœ¨

    start_message_content = (
        "GOAL: Ask the user (through text conversation) for approprivate values "
        "for the variables expected by `done`. "
        "Describe these variables to the user "
        "to help them understand what is expected "
        "(mention the $DMPATH environment variable of `validator`)."
        "\n"
        "If the user mentions a file that doesn't exist, "
        "try to look for likely typos in their input. "
        "Try also to list files in the directory "
        "to see if you can guess what the user may have meant."
        "\n"
        "If the dm_path is a Python file, "
        "suggest that the validator could be `mypy` "
        "(with an appropriate MYPATH=\"â€¦\" value) "
        "or `python3` (with an appropriate PYTHONPATH=\"â€¦\" value)."
        "\n"
        "Once the user has given you appropriate values, "
        "your goal is achieved and you should run `done`.")
    # âœ¨ initial parameters
    commands_registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(dm_path_variable, ArgumentContentType.PATH_UNVALIDATED,
                     "The path to the DM file to implement."),
            Argument(
                validator_variable, ArgumentContentType.STRING,
                "A shell command string to validate the implemented file, using $DMPATH."
            ),
        ],
        done_validator_callback=done_validator,
        file_access_policy=self._options.agent_loop_options.file_access_policy)

    initial_message = await prepare_initial_message(start_message_content, [])

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name="initial_parameters",
        start_message=initial_message,
        command_registry=commands_registry)

    dm_path_value = output_variables.get(dm_path_variable)
    validator_command_str = output_variables.get(validator_variable)

    # These assertions are safe because done_validator would have already ensured their types.
    assert isinstance(dm_path_value, str)
    assert isinstance(validator_command_str, str)

    return PathAndValidator(
        dm_path=pathlib.Path(dm_path_value),
        validator=Validator(command=validator_command_str))
    # âœ¨

  async def _find_relevant_paths(
      self, path: pathlib.Path) -> dict[MarkerName, set[pathlib.Path]]:
    """Finds all relevant markers.

    {{ðŸ¦” Calls `find_relevant_paths_for_marker` exactly once for each marker
         found in `path`.}}
    {{ðŸ¦” Calls to `find_relevant_paths_for_marker` happen concurrently.}}
    {{ðŸ¦” The output contains one entry for each marker found in `path`.}}
    {{ðŸ¦” The output values correspond to the outputs of
         `_find_relevant_paths_for_marker` for each key (marker).}}
    """
    # âœ¨ find relevant paths loop
    markers = await get_markers(char=MUSHROOM, path=path)
    tasks = []
    for marker in markers:
      tasks.append(self._find_relevant_paths_for_marker(path, marker))

    results = await asyncio.gather(*tasks)

    return {marker: result for marker, result in zip(markers, results)}
    # âœ¨

  async def _find_relevant_paths_for_marker(
      self, path: pathlib.Path, marker: MarkerName) -> set[pathlib.Path]:
    """Finds all relevant paths to implement a single DM marker.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`. The agent is focused exclusively on `marker`,
    with the goal of identifying the best value for `relevant_paths_variable`.

    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `relevant_paths_variable`.}}
    """

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Verifies that all inputs[relevant_paths_variable] values are readable.

      {{ðŸ¦” If no files are given, validation fails, with a message that at least
           one relevant file should be given.}}
      {{ðŸ¦” All files must be readable (both by the OS as well as allowed by the
           `file_access_policy`). If one isn't, validation fails.}}
      {{ðŸ¦” If all files are readable (both by the OS and `file_access_policy`),
           validation succeeds.}}
      """
      # âœ¨ relevant paths validator
      relevant_paths_str = inputs.get(relevant_paths_variable)
      if not relevant_paths_str:
        return ValidationResult(
            success=False,
            output="",
            error="At least one relevant file path must be provided.")

      if not isinstance(relevant_paths_str, str):
        return ValidationResult(
            success=False,
            output="",
            error=f"The relevant paths for '{relevant_paths_variable}' must be a comma-separated string of paths."
        )

      paths = [
          pathlib.Path(p.strip())
          for p in relevant_paths_str.split(',')
          if p.strip()
      ]

      for p in paths:
        if not p.exists():
          return ValidationResult(
              success=False,
              output="",
              error=f"Relevant file '{p}' does not exist.")
        if not self._options.agent_loop_options.file_access_policy.allow_access(
            str(p)):
          return ValidationResult(
              success=False,
              output="",
              error=f"Access to relevant file '{p}' is not allowed by policy.")

      return ValidationResult(
          success=True,
          output="Relevant paths validated successfully.",
          error="")
      # âœ¨

    start_message_content = (
        f"GOAL: identify local file paths that are relevant "
        f"to replace the line that contains '{{{{{MUSHROOM} {marker.name}}}}}' "
        f"from \"{path}\" (included below) with valid code."
        f"\n"
        f"These relevant paths should be given to the "
        f"`{relevant_paths_variable}` argument of the `done` command."
        f"\n"
        f"Example: `done(relevant_paths=\"src/foo.py,src/bar.cc\")"
        f"\n"
        f"Feel free to use `read_file`, `list_files` and `search_file` "
        f"to explore the codebase.")

    # âœ¨ find relevant paths
    commands_registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                relevant_paths_variable, ArgumentContentType.STRING,
                "A comma-separated list of local files that are relevant to implement the marker."
            )
        ],
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy)

    initial_message = await prepare_initial_message(start_message_content,
                                                    [path])

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name=f"find_relevant_paths_for_{marker.name}",
        start_message=initial_message,
        command_registry=commands_registry)

    relevant_paths_str = output_variables.get(relevant_paths_variable)

    # These assertions are safe because done_validate would have already ensured their types and validity.
    assert isinstance(relevant_paths_str, str)

    return {
        pathlib.Path(p.strip())
        for p in relevant_paths_str.split(',')
        if p.strip()
    }
    # âœ¨

  async def _implement_file(
      self, inputs: PathAndValidator,
      relevant_paths: dict[MarkerName, set[pathlib.Path]]) -> None:
    """Implements all DM markers in `inputs.output_path()` sequentially.

    {{ðŸ¦” The calls to `_implement_marker` happen sequentially.}}
    {{ðŸ¦” The output of a call to `_implement_marker` is stored through
         `MarkerImplementation.save` on `inputs.output_path()`.}}
    {{ðŸ¦” The output of a call to `_implement_marker` is stored before the next
         call begins (so that the next call already sees the output of the
         previous call).}}
    """
    # âœ¨ implement file
    markers = await get_markers(char=MUSHROOM, path=inputs.output_path())
    for marker in markers:
      marker_relevant_paths = relevant_paths[marker]
      implementation = await self._implement_marker(marker,
                                                    marker_relevant_paths,
                                                    inputs.validator,
                                                    inputs.output_path())
      await implementation.save(inputs.output_path())
    # âœ¨

  async def _implement_marker(
      self, marker: MarkerName, relevant_paths: set[pathlib.Path],
      validator: Validator, output_path: pathlib.Path) -> MarkerImplementation:
    """Finds a suitable implementation for `marker` from `output_path`.

    Calls `run_agent_loop` passing outputs of `prepare_command_registry` and
    `prepare_initial_message`. The agent is focused exclusively on `marker`,

    The AI outputs the implementation code to `done` through
    `implementation_variable`.

    {{ðŸ¦” For each file in `relevant_paths`, there's a section in the initial
         message given to the AI.}}
    {{ðŸ¦” The only done command argument given to `prepare_command_registry` is
         `implementation_variable`.}}

    Arguments:
      marker: The marker to implement.
      relevant_paths: A list of relevant paths. Tells the AI that it must
        read all these paths as well as `output_path` before doing anything else.
      validator: The validator used to verify a plausible implementation.
      output_path: The input file with the context for implementing `marker`. We
        do not actually update it (our customer does).

    Returns:
      A validated MarkerImplementation that customers can call `save` on.
    """

    async def done_validate(inputs: VariableMap) -> ValidationResult:
      """Calls validator.validate_marker_implementation to validate."""
      # âœ¨ implement validator
      implementation_code = inputs.get(implementation_variable)
      if not isinstance(implementation_code, str):
        return ValidationResult(
            success=False,
            output="",
            error=f"The implementation for '{implementation_variable}' must be a string."
        )

      try:
        file_extension = FileExtension(output_path.suffix[1:])
        marker_impl = MarkerImplementation(
            name=marker,
            value=implementation_code,
            file_extension=file_extension)
        return await validator.validate_marker_implementation(
            source=output_path, implementation=marker_impl)
      except ValueError as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"MarkerImplementation creation failed: {e}")
      except Exception as e:
        return ValidationResult(
            success=False,
            output="",
            error=f"An unexpected error occurred during validation: {e}. Please check the implementation code."
        )
      # âœ¨

    file_extension = FileExtension(output_path.suffix[1:])
    start_message_content = (
        "GOAL: provide the *code content* "
        "that will replace the line containing the "
        f"'{{{{{MUSHROOM} {marker.name}}}}}' marker "
        f"in the file '{output_path}'."
        "\n"
        "The implementation block *must* strictly follow this format:"
        "\n"
        "* It must begin with line containing nothing but "
        f"\"{comment_string(file_extension, 'âœ¨ ' + marker.name)}\" "
        "(preceded by whitespace characters to match "
        "the indentation of the block that contains the implementation)."
        "\n"
        "It must end with a line containing "
        f"nothing but \"{comment_string(file_extension, 'âœ¨')}\" "
        "(also preceded by whitespace)."
        "\n"
        "Once you have the complete and correct implementation code, "
        "call the `done` command. "
        f"The `done` command requires an argument `{implementation_variable}` "
        "which *must* be your full implementation block as a single string.")
    # âœ¨ implement single marker
    commands_registry = await prepare_command_registry(
        done_command_arguments=[
            Argument(
                implementation_variable, ArgumentContentType.STRING,
                "The code content for the implementation block, including start and end markers."
            )
        ],
        done_validator_callback=done_validate,
        file_access_policy=self._options.agent_loop_options.file_access_policy)

    initial_message_files = [output_path] + list(relevant_paths)
    initial_message = await prepare_initial_message(start_message_content,
                                                    initial_message_files)

    output_variables = await run_agent_loop(
        workflow_options=self._options,
        conversation_name=f"implement_marker_for_{marker.name}",
        start_message=initial_message,
        command_registry=commands_registry)

    implementation_code = output_variables.get(implementation_variable)

    # These assertions are safe because done_validate would have already ensured their types and validity.
    assert isinstance(implementation_code, str)

    return MarkerImplementation(
        name=marker, value=implementation_code, file_extension=file_extension)
    # âœ¨


class CodeSpecsWorkflowFactory(AgentWorkflowFactory):

  def name(self) -> str:
    return "dm"

  async def new(self, agent_workflow_options: AgentWorkflowOptions,
                args: dict[str, str]) -> AgentWorkflow:
    return CodeSpecsWorkflow(agent_workflow_options)
