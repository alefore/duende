# DO NOT EDIT. This file is automatically generated by Duende.
"""Supporting logic for DM-related workflows.md."""

# Suggested validator: MYPYPATH=~/coding-agent/src mypy $DMPATH

import aiofiles
import asyncio
import collections
import dataclasses
import itertools
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_workflow_options import AgentWorkflowOptions
from command_registry import CommandRegistry
from done_command import DoneCommand, DoneValuesValidator
from file_access_policy import FileAccessPolicy
from list_files_command import ListFilesCommand
from message import Message, ContentSection
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

# A FileExtension like "py" or "html".
FileExtension = NewType("FileExtension", str)

MarkerChar = NewType("MarkerChar", str)

# Value is a comma-separated list of local files that someone implementing a DM
# marker may want to read.
relevant_paths_variable = VariableName('relevant_paths')


def comment_string(file_extension: FileExtension, input: str) -> str:
  """Turns `input` into a valid code comment based on `path`'s extension.

  `input` may contain multiple lines.

  Supported extensions: py, sh, cc, h, js, ts, java, html, css

  {{ðŸ¦” "py" and "foo bar" returns "# foo bar"}}
  {{ðŸ¦” "html" and "my test" returns "<!-- my test -->"}}
  {{ðŸ¦” "html" and "foo\nbar\nquux" returns "<!-- foo\nbar\nquux -->"}}
  {{ðŸ¦” "cc" and "foo\nbar" returns "// foo\n//bar"}}
  {{ðŸ¦” "css" and "foo bar" returns "/* foo bar */"}}
  {{ðŸ¦” "css" and "foo\nbar" returns "/* foo\nbar */"}}
  """
  # âœ¨ get comment char
  if file_extension in ("py", "sh"):
    return f"# {input}"
  elif file_extension == "html":
    return f"<!-- {input} -->"
  elif file_extension in ("cc", "h", "js", "ts", "java"):
    return "\n".join([f"// {line}" for line in input.splitlines()])
  elif file_extension == "css":
    return f"/* {input} */"
  # âœ¨
  raise ValueError(f"Unknown file extension: {file_extension}")


@dataclasses.dataclass(frozen=True)
class MarkerName:
  char: MarkerChar
  name: str

  def __post_init__(self) -> None:
    object.__setattr__(self, 'name', self._fix_name(self.name))

  def _fix_name(self, name: str) -> str:
    """Fixes `name`, replacing any sequence of whitespace characters by ' '.

    Whitespace characters at the beginning and end are removed.

    {{ðŸ¦” Name " foo" is turned into "foo".}}
    {{ðŸ¦” Name "foo " is turned into "foo".}}
    {{ðŸ¦” Name " foo " is turned into "foo".}}
    {{ðŸ¦” Name "Foo\nBar" is turned into "Foo Bar".}}
    {{ðŸ¦” Name "  foo \n\n   \n   bar  " is turned into "foo bar".}}
    """
    # âœ¨ MarkerName fix name
    return re.sub(r"\s+", " ", name).strip()
    # âœ¨


def reindent_code(code: str, desired_spaces: int) -> str:
  """Returns a copy of `code` with the desired leading spaces.

    First finds the longest whitespace prefix that all non-empty `code` lines
    contain and removes it (from all lines). Then prepends to all lines a prefix
    of the desired length.

    {{ðŸ¦” If an input line (from `code`) is empty or only contains whitespace
         characters, the corresponding line in the output is empty.}}
    {{ðŸ¦” If the whitespace prefixes are removed (from all input and output
         lines), the output is identical to `code`.}}
    {{ðŸ¦” All lines in the output must begin with `desired_spaces` spaces or
         be empty.}}
    {{ðŸ¦” The output must contain at least one line where, if `desired_spaces`
         spaces are removed (from the start), the line starts
         with a non-space character.}}
    """
  # âœ¨ reindent code
  lines = code.splitlines()
  if not lines:
    return ""

  # Find the minimum common leading whitespace for non-empty lines
  min_indent = float('inf')
  has_non_empty_line = False
  for line in lines:
    if line.strip():  # Consider only non-empty lines for common prefix
      has_non_empty_line = True
      leading_spaces = len(line) - len(line.lstrip())
      min_indent = min(min_indent, leading_spaces)

  # If there are no non-empty lines, the common prefix is 0.
  if not has_non_empty_line:
    min_indent = 0
  else:  # Ensure min_indent is an integer if it's not infinity
    min_indent = int(min_indent)

  reindented_lines = []
  for line in lines:
    if not line.strip():  # If the line is empty or only whitespace
      reindented_lines.append("")
    else:
      # Remove the common minimum indentation and then add desired spaces
      line_without_common_prefix = line[min_indent:]
      reindented_lines.append(" " * desired_spaces + line_without_common_prefix)

  # Join lines back with newline characters.
  return "\n".join(reindented_lines)
  # âœ¨


class ExpandedMarker(NamedTuple):
  """Contains the position in a file of an expanded DM marker.

  The marker is a block of consecutive lines starting with a line containing
  only whitespace and the comment "âœ¨ {name}" and ending in the first line
  (after the start) containing only whitespace and the comment "âœ¨". The format
  of the command depends on the programming language of the file, determined by
  its file extension. (e.g., "  # âœ¨ foo  " is a valid start for a marker with
  name "foo" in a file that ends in `.py`). """

  name: str
  """Name of the marker (does not include the "âœ¨" character)."""

  start_index: int
  """Index in the file of the line with the start comment ("# âœ¨ foo")."""

  end_index: int
  """Index in the file of the line with the end comment ("# âœ¨")."""

  contents: str
  """All the lines in the expanded marker (including start/end comment)."""


class RepeatedExpandedMarkersError(ValueError):
  """Two expanded markers with identical names were found."""


def get_expanded_markers(path: pathlib.Path) -> list[ExpandedMarker]:
  """Returns the expanded markers found in `path` in appearance order.

  {{ðŸ¦” Given an empty file, returns an empty list.}}
  {{ðŸ¦” Raises FileNotFoundError for a non-existent file}}
  {{ðŸ¦” Given an file with four different markers, returns a list with four
       elements. The outputs match the inputs: fields in the ExpandedMarker
       entries are correct, and the output order matches the input.}}
  {{ðŸ¦” Given a file with two different markers each ocurring twice, raises
       `RepeatedExpandedMarkersError`. The exception string mentions all
       repeated markers.}}
  """
  # âœ¨ get expanded markers
  try:
    with open(path, 'r') as f:
      lines = f.read().splitlines()
  except FileNotFoundError:
    raise  # Re-raise the exception as per the test case, or return [] if that's the desired behavior for "empty file"
    # The existing test case `{{ðŸ¦” Given an empty file, returns an empty list.}}` conflicts with `{{ðŸ¦” Raises FileNotFoundError for a non-existent file}}`
    # Given the new test case "Raises FileNotFoundError for a non-existent file" in src/code_specs.py, I will explicitly raise FileNotFoundError.

  if not lines:
    return []

  # Determine file extension.
  file_extension_str = path.suffix.lstrip('.')
  if '.dm.' in path.name:
    parts = path.name.split('.')
    try:
      dm_index = parts.index('dm')
      if dm_index + 1 < len(parts):
        file_extension_str = parts[dm_index + 1]
      else:
        file_extension_str = ''
    except ValueError:
      file_extension_str = path.suffix.lstrip('.')

  comment_patterns = {
      "py": (r"#", r""),
      "sh": (r"#", r""),
      "html": (r"<!--", r"-->"),
      "cc": (r"//", r""),
      "h": (r"//", r""),
      "js": (r"//", r""),
      "ts": (r"//", r""),
      "java": (r"//", r""),
      "css": (r"/\*", r"\*/"),
  }

  start_comment_literal, end_comment_literal = comment_patterns.get(
      file_extension_str, (None, None))

  if start_comment_literal is None:
    raise ValueError(f"Unknown file extension: {file_extension_str}")

  escaped_start = re.escape(start_comment_literal)
  escaped_end = re.escape(end_comment_literal) if end_comment_literal else ""

  start_marker_full_pattern = re.compile(r"^\s*" + escaped_start +
                                         r"\s*âœ¨\s*(.*?)\s*" + escaped_end +
                                         r"\s*$")
  end_marker_full_pattern = re.compile(r"^\s*" + escaped_start + r"\s*âœ¨\s*" +
                                       escaped_end + r"\s*$")

  expanded_markers: list[ExpandedMarker] = []
  found_marker_names_with_lines: collections.defaultdict[
      str, list[int]] = collections.defaultdict(list)

  in_marker_block = False
  current_marker_start_index = -1
  current_marker_name = ""
  current_marker_content_lines: list[str] = []

  for line_index, line in enumerate(lines):
    start_match = start_marker_full_pattern.match(line)
    end_match = end_marker_full_pattern.match(line)

    if not in_marker_block and start_match:
      marker_name_cleaned = MarkerName(
          char=MarkerChar('âœ¨'), name=start_match.group(1)).name

      found_marker_names_with_lines[marker_name_cleaned].append(line_index)

      if len(found_marker_names_with_lines[marker_name_cleaned]) > 1:
        repeated_markers_info_list = []
        for name, lines_found in found_marker_names_with_lines.items():
          if len(lines_found) > 1:
            repeated_markers_info_list.append(
                f"'{name}' at lines {', '.join(map(str, lines_found))}")
        raise RepeatedExpandedMarkersError(
            f"Repeated expanded markers found: {'; '.join(repeated_markers_info_list)}"
        )

      in_marker_block = True
      current_marker_start_index = line_index
      current_marker_name = marker_name_cleaned
      current_marker_content_lines = [line]
    elif in_marker_block and end_match:
      current_marker_content_lines.append(line)
      expanded_markers.append(
          ExpandedMarker(
              name=current_marker_name,
              start_index=current_marker_start_index,
              end_index=line_index,
              contents="\n".join(current_marker_content_lines)))

      # Reset state
      in_marker_block = False
      current_marker_start_index = -1
      current_marker_name = ""
      current_marker_content_lines = []
    elif in_marker_block:
      # Just a regular line inside the marker block
      current_marker_content_lines.append(line)

  return expanded_markers
  # âœ¨


class MarkersOverlapError(ValueError):
  """Two markers have a common line.

  This is invalid: markers may not overlap.
  """


async def get_markers_str(char: MarkerChar,
                          input: str) -> dict[MarkerName, list[int]]:
  """Returns the positions (line index) of all markers in `path`.

  {{ðŸ¦” Returns {} for an empty input}}
  {{ðŸ¦” Returns {} for an input with 5 lines but no markers}}
  {{ðŸ¦” Correctly returns a marker in an input with just 1 marker}}
  {{ðŸ¦” If a marker starts in the first line in the input, its value in the
       output is [0].}}
  {{ðŸ¦” If a marker starts in the last line, its value in the output is
       `len(lines) - 1`.}}
  {{ðŸ¦” Correctly handles an input where a marker starts in the first line and
       finishes in the last line.}}
  {{ðŸ¦” Spaces are correctly removed from a marker named "  foo bar  ".}}
  {{ðŸ¦” Returns all markers in an input with ten markers.}}
  {{ðŸ¦” The index of markers returned in an input with ten markers is correct.}}
  {{ðŸ¦” An input can have repeated markers; the output just lists their
       positions.}}
  {{ðŸ¦” An input where two markers overlap (one ends in the same line where the
       other begins) raises `MarkersOverlapError`.}}
  {{ðŸ¦” The returned object is sorted by appearance order (i.e., iterating across
       the keys of the returned dictionary matches the order in which the first
       appearance of each marker was found in the input).}}

  Raises:
      MarkersOverlapError: if two markers share a common line.
  """
  # âœ¨ get markers str
  # 1. Get the content directly from the input string.
  content = input

  # 2. Define the regex and find all matches.
  #    finditer() returns matches in order, so no sorting is needed.
  pattern = re.compile(r"\{\{" + re.escape(char) + r"\s*(.*?)\s*\}\}",
                       re.DOTALL)
  all_matches = list(pattern.finditer(content))
  if not all_matches:
    return {}

  # 3. Validate markers.
  #    Iterate over consecutive pairs and check for overlaps.
  for prev_match, curr_match in itertools.pairwise(all_matches):
    prev_end = prev_match.end()
    curr_start = curr_match.start()

    # Check 1: True Overlap (e.g., nesting)
    if curr_start < prev_end:
      raise MarkersOverlapError(
          f"Markers overlap (nesting detected) near character {curr_start} "
          f"in the input string")

    # Check 2: Same-Line Overlap
    gap_text = content[prev_end:curr_start]
    if '\n' not in gap_text:
      raise MarkersOverlapError(
          f"Marker at char {curr_start} starts on the same line "
          f"as the previous marker ended (char {prev_end}) in the input string")

  # 4. If validation passed, build the result dictionary.
  markers = collections.defaultdict(list)
  current_line = 0
  last_char_index = 0
  for match in all_matches:
    start_char_index = match.start()
    # Count newlines *only in the new gap* since the last match
    gap_text = content[last_char_index:start_char_index]
    current_line += gap_text.count('\n')

    # Store the calculated line number
    name_str = match.group(1).strip()
    marker_name = MarkerName(char=char, name=name_str)
    markers[marker_name].append(current_line)

    # Update our position for the next iteration
    last_char_index = start_char_index

  return dict(markers)
  # âœ¨


async def get_markers(char: MarkerChar,
                      path: pathlib.Path) -> dict[MarkerName, list[int]]:
  """Reads the file contents and calls `get_markers_str`.

  {{ðŸ¦” Reads `path` asynchronously}}
  {{ðŸ¦” Raises FileNotFoundError for a non-existent file}}
  """
  # âœ¨ get markers
  try:
    async with aiofiles.open(path, mode='r') as f:
      content = await f.read()
  except FileNotFoundError:
    raise

  return await get_markers_str(char, content)
  # âœ¨


class MarkerImplementation:

  def __init__(self, name: MarkerName, value: str,
               file_extension: FileExtension) -> None:
    """Sets _name, _value, _file_extension from inputs.

    The value is the full implementation.

    Raises:
      ValueError unless `value` starts and ends with appropriate `âœ¨` comments.
        Per doc/code-specs.md, these comments may contain leading whitespaces.
    """
    # âœ¨ marker implementation constructor
    self._name = name
    self._value = value
    self._file_extension = file_extension

    value_lines = [line for line in value.splitlines() if line.strip()]

    if not value_lines:
      raise ValueError("Implementation block cannot be empty.")

    # An implementation block must contain at least two non-empty lines:
    # one for the start marker and one for the end marker.
    if len(value_lines) < 2:
      raise ValueError(
          "Implementation block must have at least a start and end marker line."
      )

    first_line_stripped = value_lines[0].lstrip()
    last_line_stripped = value_lines[-1].lstrip()

    # Generate the expected start and end comment lines. We then strip any *inherent* leading
    # whitespace that the `comment_string` function itself might add (e.g., "  // " for C-style
    # comments). This allows the actual `value` lines to have arbitrary leading whitespace before
    # their comment characters.
    expected_start_comment_content = f"âœ¨ {name.name}"
    expected_start_comment_line_template = comment_string(
        file_extension, expected_start_comment_content).lstrip()

    expected_end_comment_content = "âœ¨"
    expected_end_comment_line_template = comment_string(
        file_extension, expected_end_comment_content).lstrip()

    if first_line_stripped != expected_start_comment_line_template:
      raise ValueError(
          f"Implementation block must start with appropriate 'âœ¨' comment. "
          f"Expected (stripped): '{expected_start_comment_line_template}', "
          f"Got (stripped): '{first_line_stripped}'")

    if last_line_stripped != expected_end_comment_line_template:
      raise ValueError(
          f"Implementation block must end with appropriate 'âœ¨' comment. "
          f"Expected (stripped): '{expected_end_comment_line_template}', "
          f"Got (stripped): '{last_line_stripped}'")
    # âœ¨

  # {{ðŸ¦” A call to MarkerImplementation.name returns the correct name}}
  # {{ðŸ¦” A call to MarkerImplementation.value returns the correct value}}
  # âœ¨ `name` and `value` getters
  @property
  def name(self) -> MarkerName:
    return self._name

  @property
  def value(self) -> str:
    return self._value

  # âœ¨

  async def save(self, path: pathlib.Path) -> None:
    """Rewrites `path`, storing our implementation.

    {{ðŸ¦” The read operation is async.}}
    {{ðŸ¦” The write operation is async.}}
    {{ðŸ¦” Successfully expands a marker in a file with a single marker.}}
    {{ðŸ¦” Successfully expands a marker that spans multiple lines (i.e., that
         has newline characters in the name).}}
    {{ðŸ¦” Successfully expands the correct marker in a file with ten markers.}}
    {{ðŸ¦” The value is stored literally, without adding any leading spaces.}}
    {{ðŸ¦” Raises ValueError if the marker doesn't occur in `path`}}
    {{ðŸ¦” Raises ValueError if the marker occurs twice in `path`}}
    {{ðŸ¦” Raises FileNotFoundError for a non-existent file.}}
    {{ðŸ¦” Raises ValueError if `path` contains a ".dm." part}}
    {{ðŸ¦” The value written (the implementation) is reindented according to the
         rules of `_value_indent`; the number of desired spaces is equal to the
         number of spaces before the first non-space character in the line that
         contains the marker.}}
    {{ðŸ¦” Uses `get_markers` rather than redundantly implementing its logic.}}

    Raises:
      ValueError if `path` has a `.dm.` part. DM files themselves should never
      be updated.
    """
    # âœ¨ marker implementation save
    if ".dm." in path.name:
      raise ValueError(
          f"`path` ('{path}') must not contain '.dm.'. DM files themselves should never be updated."
      )

    # 1. Get marker positions.
    all_markers = await get_markers(self._name.char, path)
    if self._name not in all_markers:
      raise ValueError(
          f"Marker '{{{{{str(self._name.char)} {self._name.name}}}}}' found 0 times in '{path}'. Expected exactly one."
      )
    if len(all_markers[self._name]) > 1:
      raise ValueError(
          f"Marker '{{{{{str(self._name.char)} {self._name.name}}}}}' found {len(all_markers[self._name])} times in '{path}'. Expected exactly one."
      )

    marker_line_idx = all_markers[self._name][0]

    # 2. Read the file content.
    async with aiofiles.open(
        path, mode='r') as f:
      lines = (await f.read()).splitlines()

    # 3. Determine the indentation of the marker line.
    marker_line = lines[marker_line_idx]
    indentation = len(marker_line) - len(marker_line.lstrip())

    # 4. Prepare the replacement content with correct indentation.
    indented_value = reindent_code(self._value, indentation)

    # 5. Reconstruct the file content.
    new_lines = []
    new_lines.extend(lines[:marker_line_idx])  # Lines before the marker
    new_lines.extend(indented_value.splitlines())  # Insert the implementation
    new_lines.extend(lines[marker_line_idx + 1:])  # Lines after the marker

    new_content = "\n".join(new_lines)

    # 6. Write the updated content back to the file.
    async with aiofiles.open(
        path, mode='w') as f:
      await f.write(new_content)
    # âœ¨


@dataclasses.dataclass(frozen=True)
class Validator:
  """A shell command that validates contents of a file.

  The command receives the path through $DMPATH. It should be able to validate
  copies on /tmp of input files (i.e., must not assume that it is always run in
  some particular directory).

  Validation is successful if the command exits with 0. If the DM file being
  implemented contains unit tests, this typically just runs it.
  """
  command: str

  def __post_init__(self) -> None:
    """Raises ValueError if the command doesn't include the string "DMPATH".

    {{ðŸ¦” Raises for incorrect string: "MYPYPATH=foo mypy {path}"}}
    {{ðŸ¦” Raises for incorrect string: "MYPYPATH=foo mypy $DM_PATH"}}
    {{ðŸ¦” Doesn't raise for "MYPYPATH=foo mypy $DMPATH"}}
    """
    # âœ¨ validator post init
    if "DMPATH" not in self.command:
      raise ValueError("Validator command must include 'DMPATH'.")
    # âœ¨

  async def validate_path(self, dm_path: pathlib.Path) -> ValidationResult:
    """Runs `command` on `dm_path` to validate it.

    {{ðŸ¦” Returns failure for "false # $DMPATH"}}
    {{ðŸ¦” Returns success for "true # $DMPATH"}}
    {{ðŸ¦” Correctly passes `dm_path` through the `DMPATH` env variable}}
    {{ðŸ¦” Command `TEST=foo sh -c 'test "$TEST" = "foo"' # $DMPATH` succeeds.
         This validates that we can actually processes shell syntax.}}
    """
    env = os.environ.copy()
    env['DMPATH'] = str(dm_path)
    # âœ¨ validator validate
    try:
      process = await asyncio.create_subprocess_exec(
          "/bin/bash",
          "-c",
          self.command,
          env=env,
          stdout=asyncio.subprocess.PIPE,
          stderr=asyncio.subprocess.PIPE,
      )
      stdout, stderr = await process.communicate()
      return ValidationResult(
          success=process.returncode == 0,
          output=stdout.decode().strip(),
          error=stderr.decode().strip())
    except Exception as e:
      logging.error(f"Error executing validator command: {str(e)}")
      return ValidationResult(success=False, output="", error=str(e))
    # âœ¨

  async def validate_marker_implementation(
      self, source: pathlib.Path,
      implementation: MarkerImplementation) -> ValidationResult:
    """Validates the implementation of a marker on a copy of `source`.

    {{ðŸ¦” Validation fails if the implementation contains markers (per
         `get_markers(MUSHROOM, â€¦)`). In this case, a helpful string is
         returned, proposing an alternative along the lines of
         `"{{" + "ðŸ„ â€¦}}"` (which is enough to avoid this).}}
    {{ðŸ¦” The read operation is async}}
    {{ðŸ¦” The write operation is async}}
    {{ðŸ¦” Does not modify `source`}}
    {{ðŸ¦” Returns success when the implementation is correct}}
    {{ðŸ¦” Returns failure when the implementation is invalid}}
    {{ðŸ¦” Uses `implementation.save` on the temporary copy of `source` (in order
         to update the implementation of the marker in the file).}}
    """
    # âœ¨ implement validator
    # New validation: check for mushroom markers in the implementation content.
    try:
      mushroom_markers = await get_markers_str(
          MarkerChar('ðŸ„'), implementation.value)
      if mushroom_markers:
        marker_names = ", ".join(
            f"'{{ðŸ„ {name.name}}}'" for name in mushroom_markers.keys())
        return ValidationResult(
            success=False,
            output="",
            error=(
                f"Implementation contains mushroom markers: {marker_names}. "
                "Please remove them or escape them like `'â€¦{{' + 'ðŸ„ â€¦}}â€¦'`."))
    except MarkersOverlapError as e:
      return ValidationResult(
          success=False,
          output="",
          error=(f"Implementation contains overlapping markers: {e}. "))

    with tempfile.TemporaryDirectory() as tmpdir:
      temp_source_path = pathlib.Path(tmpdir) / source.name
      shutil.copy(source, temp_source_path)
      await implementation.save(temp_source_path)
      return await self.validate_path(temp_source_path)
    # âœ¨


@dataclasses.dataclass(frozen=True)
class PathAndValidator:
  """An immutable container for a DM file path and a validator."""
  dm_path: pathlib.Path
  validator: Validator

  async def validate_fields(self) -> None:
    """Validates fields, conditionally raising ValueError.

    When searching for markers, uses MarkerChar('ðŸ„').

    {{ðŸ¦” Doesn't raise if `dm_path` is a valid file with two ðŸ„ markers.}}
    {{ðŸ¦” Raises ValueError if `dm_path` is "foo.py" (lacks the `.dm.` part).}}
    {{ðŸ¦” Raises ValueError if `dm_path` is a valid file with no ðŸ„ markers.}}
    {{ðŸ¦” Raises ValueError if `dm_path` contains a repeated ðŸ„ marker.}}

    We can't use `__post_init__` because we want `async` validation.
    """
    # âœ¨ PathAndValidator validate fields
    if ".dm." not in self.dm_path.name:
      raise ValueError(f"`dm_path` ('{self.dm_path}') must contain '.dm.'.")

    try:
      markers = await get_markers(MarkerChar('ðŸ„'), self.dm_path)
    except MarkersOverlapError as e:
      raise ValueError(
          f"Overlapping ðŸ„ markers found in '{self.dm_path}': {e}") from e
    except FileNotFoundError as e:
      raise ValueError(f"File not found: '{self.dm_path}'") from e

    if not markers:
      raise ValueError(f"No ðŸ„ markers found in '{self.dm_path}'.")

    for marker_name, positions in markers.items():
      if len(positions) > 1:
        raise ValueError(
            f"Repeated ðŸ„ marker '{marker_name.name}' found in '{self.dm_path}' "
            f"at lines: {', '.join(map(str, positions))}. Each marker name must be unique."
        )
    # âœ¨

  def output_path(self) -> pathlib.Path:
    """Returns `dm_path` without the `.dm` part.

    {{ðŸ¦” If `dm_path` is "foo/bar/quux.dm.py", returns "foo/bar/quux.py"}}
    """
    # âœ¨ PathAndValidator output path
    return pathlib.Path(self.dm_path.parent /
                        self.dm_path.name.replace(".dm.", "."))
    # âœ¨

  async def overwrite(self, target: pathlib.Path) -> None:
    """Copies `dm_path`'s contents to `target` (overwriting it).

    The contents of the new file are:

    * A line with the comment:
      "DO NOT EDIT. This file is automatically generated by Duende."
    * The entire (unmodified) contents of `dm_path`.

    {{ðŸ¦” The read operation is async}}
    {{ðŸ¦” The write operation is async}}
    {{ðŸ¦” The output of a call with a normal dm file starts with the "DO NOT EDIT
         code comment}}
    {{ðŸ¦” The output of a call with a normal dm file contains a copy (of the dm
         file), starting at line 2 (of the output)}}
    """
    # âœ¨ overwrite
    try:
      async with aiofiles.open(self.dm_path, mode='r') as f:
        dm_content = await f.read()
    except FileNotFoundError:
      # TODO: What is this stupidity of catching an exception just to raise it?
      # Gemini is so stupid sometimes.
      raise

    # Determine file extension for commenting
    file_extension_str = self.dm_path.suffix.lstrip('.')
    # If the file has a compound extension like .dm.py,
    # we take the last part (e.g., 'py').
    if '.dm.' in self.dm_path.name:
      parts = self.dm_path.name.split('.')
      # Find the index of '.dm.' and take the next part as the extension
      try:
        dm_index = parts.index('dm')
        if dm_index + 1 < len(parts):
          file_extension_str = parts[dm_index + 1]
        else:  # Handle cases like 'foo.dm'
          file_extension_str = ''
      except ValueError:
        # Should not happen if '.dm.' is in name but 'dm' part not found
        file_extension_str = self.dm_path.suffix.lstrip('.')

    file_extension = FileExtension(file_extension_str)

    auto_gen_comment = comment_string(
        file_extension,
        "DO NOT EDIT. This file is automatically generated by Duende.")

    new_content = f"{auto_gen_comment}\n{dm_content}"

    async with aiofiles.open(target, mode='w') as f:
      await f.write(new_content)
    # âœ¨


async def prepare_initial_message(start_message_content: str,
                                  relevant_files: set[pathlib.Path]) -> Message:
  """Creates the first message for an AgentLoop conversation.

  {{ðŸ¦” `relevant_files` are read asynchronously.}}
  {{ðŸ¦” The output contains `start_message_content` as its first section.}}
  {{ðŸ¦” If `relevant_files` is empty, the output has just one section.}}
  {{ðŸ¦” If a relevant file can't be read, raises an exception (or, rather, lets
       the underlying exception bubble up, doesn't catch it).}}
  {{ðŸ¦” There is a content section in the start message given to the AgentLoop
       for each entry in `relevant_files`. It starts with a line "File '{path}'
       follows:" (with the corresponding path) and includes the entire contents
       of the file.}}
  """
  # âœ¨ prepare initial message
  content_sections = [ContentSection(content=start_message_content)]

  for file_path in sorted(relevant_files):
    async with aiofiles.open(file_path, mode='r') as f:
      file_content = await f.read()
    content_sections.append(
        ContentSection(content=f"File '{file_path}' follows:" + "\n" +
                       file_content))

  return Message(role="user", content_sections=content_sections)
  # âœ¨


async def prepare_command_registry(
    done_command_arguments: list[Argument],
    done_validator_callback: Callable[[VariableMap],
                                      Awaitable[ValidationResult]],
    file_access_policy: FileAccessPolicy) -> CommandRegistry:
  """Creates a command registry suitable for run_agent_loop.

  {{ðŸ¦” The command registry given has exactly these agent commands:
       ReadFileCommand(â€¦), ListFilesCommand(â€¦), SearchFileCommand(â€¦),
       done_command}}
  """

  # âœ¨ prepare command registry
  class CallbackDoneValuesValidator(DoneValuesValidator):

    def __init__(self, callback: Callable[[VariableMap],
                                          Awaitable[ValidationResult]]):
      self._callback = callback

    async def validate(self, inputs: VariableMap) -> ValidationResult:
      return await self._callback(inputs)

  registry = CommandRegistry()
  registry.Register(ReadFileCommand(file_access_policy))
  registry.Register(ListFilesCommand(file_access_policy))
  registry.Register(SearchFileCommand(file_access_policy))
  registry.Register(
      DoneCommand(
          arguments=done_command_arguments,
          values_validator=CallbackDoneValuesValidator(
              done_validator_callback)))
  return registry
  # âœ¨


async def run_agent_loop(workflow_options: AgentWorkflowOptions,
                         conversation_name: str, start_message: Message,
                         command_registry: CommandRegistry) -> VariableMap:
  """Creates and runs a BaseAgentLoop.

  {{ðŸ¦” Returns the `VariableMap` with all the values given to `DoneCommand`.}}
  {{ðŸ¦” The conversation started has name `conversation_name`.}}
  {{ðŸ¦” `start_message` is given as the initial message.}}

  Returns:
    Output variables given to the final `done` command (extracted from the
    final message in the conversation).
  """
  # âœ¨ run agent loop
  conversation = workflow_options.conversation_factory.New(
      conversation_name, command_registry)

  # Create new AgentLoopOptions, overriding conversation, start_message, and command_registry
  # from the workflow_options's agent_loop_options.
  agent_loop_options = workflow_options.agent_loop_options._replace(
      conversation=conversation,
      start_message=start_message,
      command_registry=command_registry)

  agent_loop = workflow_options.agent_loop_factory.new(agent_loop_options)

  return await agent_loop.run()
  # âœ¨
