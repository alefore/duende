# DO NOT EDIT. This file is automatically generated by Duende.
"""Supporting logic for DM-related workflows.md."""

import aiofiles
import asyncio
import dataclasses
import logging
import pathlib
import re
import os
import shutil
import subprocess
import tempfile
from typing import Awaitable, Callable, NamedTuple, NewType, Pattern, Sequence

from agent_command import Argument, ArgumentContentType, VariableMap, VariableName, VariableValue
from agent_loop_options import AgentLoopOptions
from agent_workflow_options import AgentWorkflowOptions
from command_registry import CommandRegistry
from done_command import DoneCommand, DoneValuesValidator
from file_access_policy import FileAccessPolicy
from list_files_command import ListFilesCommand
from message import Message, ContentSection
from read_file_command import ReadFileCommand
from search_file_command import SearchFileCommand
from validation import ValidationResult
from write_file_command import WriteFileCommand

# A FileExtension like "py" or "html".
FileExtension = NewType("FileExtension", str)

MarkerChar = NewType("MarkerChar", str)


def comment_string(file_extension: FileExtension, input: str) -> str:
  """Turns `input` into a valid code comment based on `path`'s extension.

  Supported extensions: py, sh, cc, h, js, ts, java, html, css

  {{ðŸ¦” "py" and "foo bar" returns "# foo bar"}}
  {{ðŸ¦” "html" and "my test" returns "<!-- my test -->}}
  """
  # âœ¨ get comment char
  if file_extension == "py" or file_extension == "sh":
    return f"# {input}"
  elif file_extension == "cc" or file_extension == "h" or file_extension == "js" or file_extension == "ts" or file_extension == "java":
    return f"// {input}"
  elif file_extension == "html":
    return f"<!-- {input} -->"
  elif file_extension == "css":
    return f"/* {input} */"


# âœ¨
  raise ValueError(f"Unknown file extension: {file_extension}")


def marker_pattern(char: str) -> re.Pattern:
  """Returns a regex to search for code lines with DM markers.

  A DM marker has the form "{{" + char + an arbitrary name (which may
  contain spaces, such as "    test method foo  ") + "}}". The first match group
  captures the name, with any leading/trailing spaces stripped away. Must be
  applied to individual lines (i.e., not to the whole file).

  {{ðŸ¦” Matches "      {{X foo}}" (with char "X")}}
  {{ðŸ¦” Matches "  return Foo()   #  {{X bar}} blah" (char == "X")}}
  {{ðŸ¦” Doesn't match with space before char: "{{ X foo}}" (char == "X")}}
  {{ðŸ¦” Doesn't match random line "  if (kobolds_found) {"}}
  """
  # âœ¨ marker pattern
  return re.compile(r'\{\{' + re.escape(char) + r'\s*(.*?)\s*\}\}')


# âœ¨


class MarkerName(NamedTuple):
  char: MarkerChar
  name: str


class MarkerImplementation:

  def __init__(self, name: MarkerName, value: str,
               file_extension: FileExtension) -> None:
    """Sets _name, _value, _file_extension from inputs.

    The value is the full implementation.

    Raises:
      ValueError unless `value` starts and ends with appropriate `âœ¨` comments.
        Per doc/code-specs.md, these comments may contain leading whitespaces.
    """
    # âœ¨ marker implementation constructor
    self._name = name
    self._value = value
    self._file_extension = file_extension

    lines = value.splitlines()
    if not lines:
      raise ValueError("Implementation value cannot be empty.")

    expected_start_comment = comment_string(file_extension, f"âœ¨ {name.name}")
    expected_end_comment = comment_string(file_extension, "âœ¨")

    if lines[0].strip() != expected_start_comment:
      raise ValueError(
          f"Implementation must start with '{expected_start_comment}', but found '{lines[0]}'"
      )
    if lines[-1].strip() != expected_end_comment:
      raise ValueError(
          f"Implementation must end with '{expected_end_comment}', but found '{lines[-1]}'"
      )


# âœ¨

# {{ðŸ¦” A call to MarkerImplementation.name returns the correct name}}
# {{ðŸ¦” A call to MarkerImplementation.value returns the correct value}}
# âœ¨ `name` and `value` getters

  @property
  def name(self) -> MarkerName:
    return self._name

  @property
  def value(self) -> str:
    return self._value

  # âœ¨

  async def save(self, path: pathlib.Path) -> None:
    """Rewrites `path`, storing our implementation.

    {{ðŸ¦” The read operation is async}}
    {{ðŸ¦” The write operation is async}}
    {{ðŸ¦” Successfully expands a marker in a file with a single marker}}
    {{ðŸ¦” Successfully expands the correct marker in a file with ten markers}}
    {{ðŸ¦” The value is stored literally, without adding any leading spaces}}
    {{ðŸ¦” Raises ValueError if the marker doesn't occur in `path`}}
    {{ðŸ¦” Raises ValueError if the marker occurs twice in `path`}}
    {{ðŸ¦” Raises FileNotFound if the file does not exist}}
    {{ðŸ¦” Raises ValueError if `path` contains a ".dm." part}}
    {{ðŸ¦” The value written (the implementation) is reindented according to the
         rules of `_value_indent`; the number of desired spaces is equal to the
         number of spaces before the first non-space character in the line that
         contains the marker.}}

    Raises:
      ValueError if `path` has a `.dm.` part. DM files themselves should never
      be updated.
    """
    # âœ¨ marker implementation save
    if ".dm." in path.name:
      raise ValueError(f"DM files themselves should never be updated: {path}")

    try:
      async with aiofiles.open(path, mode="r") as f:
        content = await f.read()
    except FileNotFoundError:
      raise FileNotFoundError(f"File not found: {path}")

    lines = content.splitlines()
    char_pattern = marker_pattern(self._name.char)
    found_marker_lines: list[tuple[int, str]] = []

    for i, line in enumerate(lines):
      match = char_pattern.search(line)
      if match and match.group(1).strip() == self._name.name:
        found_marker_lines.append((i, line))

    if not found_marker_lines:
      raise ValueError(
          f"Marker '{{{{'{self._name.char} {self._name.name}'}}}}' not found in file '{path}'."
      )
    if len(found_marker_lines) > 1:
      raise ValueError(
          f"Marker '{{{{'{self._name.char} {self._name.name}'}}}}' found multiple times in file '{path}'."
      )

    marker_line_num, marker_line_content = found_marker_lines[0]

    # Calculate indentation
    indentation = len(marker_line_content) - len(marker_line_content.lstrip())

    # Re-indent the implementation
    indented_value = self._value_indent(indentation)

    # Replace the marker line with the implementation
    new_lines = lines[:marker_line_num] + indented_value.splitlines(
    ) + lines[marker_line_num + 1:]

    async with aiofiles.open(path, mode="w") as f:
      await f.write("\n".join(new_lines))
    # âœ¨

  def _value_indent(self, desired_spaces: int) -> str:
    """Returns a copy of `_value` with the desired leading spaces.

    First finds the longest whitespace prefix that all non-empty `_value` lines
    contain and removes it (from all lines). Then prepends to all lines a prefix
    of the desired length.

    {{ðŸ¦” If an input (`_value`) is empty, the corresponding line in the output
         is empty.}}
    {{ðŸ¦” If the whitespace prefixes are removed (from all input and output
         lines), the output is identical to `_value`.}}
    {{ðŸ¦” All lines in the output must begin with `desired_spaces` spaces or
         be empty.}}
    {{ðŸ¦” The output must contain at least one line where, if `desired_spaces`
         spaces are removed (from the start), the line starts
         with a non-space character.}}
    """
    # âœ¨ marker implementation value indent
    lines = self._value.splitlines()
    if not lines:
      return ""

    # Find the minimum common leading whitespace for non-empty lines
    min_indent = float('inf')
    has_content_line = False
    for line in lines:
      if line.strip():  # Only consider non-empty lines for common indent
        leading_spaces = len(line) - len(line.lstrip(' '))
        min_indent = min(min_indent, leading_spaces)
        has_content_line = True

    # If no lines had content, default min_indent to 0
    if not has_content_line:
      min_indent = 0
    else:
      min_indent = int(
          min_indent)  # Ensure it's an integer after min operations

    # Remove the common leading whitespace and prepend desired_spaces
    indented_lines = []
    prefix = " " * desired_spaces
    for line in lines:
      if not line:  # If the line is entirely empty (not just whitespace)
        indented_lines.append("")
      else:
        # Remove min_indent characters from the beginning
        # If a line is shorter than min_indent, this will result in an empty string.
        trimmed_line = line[min_indent:]
        indented_lines.append(prefix + trimmed_line)

    return "\n".join(indented_lines)
    # âœ¨


@dataclasses.dataclass(frozen=True)
class Validator:
  """A shell command that validates contents of a file.

  The command receives the path through $DMPATH. It should be able to validate
  copies on /tmp of input files (i.e., must not assume that it is always run in
  some particular directory).

  Validation is successful if the command exits with 0. If the DM file being
  implemented contains unit tests, this typically just runs it.
  """
  command: str

  def __post_init__(self):
    """Raises ValueError if the command doesn't include the string "DMPATH".

    {{ðŸ¦” Raises for incorrect string: "MYPYPATH=foo mypy {path}"}}
    {{ðŸ¦” Raises for incorrect string: "MYPYPATH=foo mypy $DM_PATH"}}
    {{ðŸ¦” Doesn't raise for "MYPYPATH=foo mypy $DMPATH"}}
    """
    # âœ¨ validator post init
    if "DMPATH" not in self.command:
      raise ValueError("Validator command must include 'DMPATH'.")
# âœ¨

  async def validate_path(self, dm_path: pathlib.Path) -> ValidationResult:
    """Runs `command` on `dm_path` to validate it.

    {{ðŸ¦” Returns failure for "false # $DMPATH"}}
    {{ðŸ¦” Returns success for "true # $DMPATH"}}
    {{ðŸ¦” Correctly passes `dm_path` through the `DMPATH` env variable}}
    {{ðŸ¦” Command `TEST=foo sh -c 'test "$TEST" = "foo"' # $DMPATH` succeeds.
         This validates that we can actually processes shell syntax.}}
    """
    env = os.environ.copy()
    env['DMPATH'] = str(dm_path)
    # âœ¨ validator validate
    process = await asyncio.create_subprocess_shell(
        self.command,
        env=env,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    stdout, stderr = await process.communicate()
    return ValidationResult(
        success=process.returncode == 0,
        output=stdout.decode().strip(),
        error=stderr.decode().strip())
# âœ¨

  async def validate_marker_implementation(
      self, source: pathlib.Path,
      implementation: MarkerImplementation) -> ValidationResult:
    """Validates the implementation of a marker on a copy of `source`.

    {{ðŸ¦” The read operation is async}}
    {{ðŸ¦” The write operation is async}}
    {{ðŸ¦” Does not modify `source`}}
    {{ðŸ¦” Returns success when the implementation is correct}}
    {{ðŸ¦” Returns failure when the implementation is invalid}}
    """
    # âœ¨ implement validator
    temp_dir = None
    try:
      temp_dir = pathlib.Path(tempfile.mkdtemp())
      temp_file_path = temp_dir / source.name

      # Copy the source file to the temporary location
      async with aiofiles.open(
          source, mode="r") as src_f:
        content = await src_f.read()
      async with aiofiles.open(temp_file_path, mode="w") as dest_f:
        await dest_f.write(content)

      # Apply the marker implementation to the temporary file
      await implementation.save(temp_file_path)

      # Validate the modified temporary file
      validation_result = await self.validate_path(temp_file_path)
      return validation_result
    finally:
      if temp_dir and temp_dir.exists():
        shutil.rmtree(temp_dir)


# âœ¨


async def get_markers(char: MarkerChar, path: pathlib.Path) -> list[MarkerName]:
  """Returns all markers in `path` in appearance order.

  {{ðŸ¦” Reads `path` asynchronously}}
  {{ðŸ¦” Returns [] for an empty file}}
  {{ðŸ¦” Raises FileNotFound for a non-existent file}}
  {{ðŸ¦” Returns [] for a file with 5 lines but no markers}}
  {{ðŸ¦” Correctly returns a marker in a file with just 1 marker}}
  {{ðŸ¦” Spaces are correctly removed from a marker named "  foo bar  "}}
  {{ðŸ¦” Returns all markers in a file with ten markers}}
  {{ðŸ¦” The order of markers returned in a file with ten markers is correct}}
  {{ðŸ¦” Raises ValueError for a file with a repeated marker (among others)}}
  {{ðŸ¦” A file with three repeated markers raises ValueError; the description
      mentions all markers explicitly}}

  Raises:
      ValueError if the file contains repeated markers.
  """
  # âœ¨ list markers
  try:
    async with aiofiles.open(path, mode="r") as f:
      content = await f.read()
  except FileNotFoundError:
    raise FileNotFoundError(f"File not found: {path}")

  lines = content.splitlines()
  found_markers: list[MarkerName] = []
  seen_marker_names = set()
  repeated_marker_names = set()

  char_pattern = marker_pattern(char)

  for line_num, line in enumerate(lines):
    match = char_pattern.search(line)
    if match:
      marker_name_str = match.group(1).strip()
      current_marker_name = MarkerName(char=char, name=marker_name_str)

      if current_marker_name in seen_marker_names:
        repeated_marker_names.add(current_marker_name)
      else:
        seen_marker_names.add(current_marker_name)
        found_markers.append(current_marker_name)

  if repeated_marker_names:
    repeated_markers_str = ", ".join(
        sorted([f"'{m.name}'" for m in repeated_marker_names]))
    raise ValueError(
        f"File '{path}' contains repeated markers: {repeated_markers_str}.")

  return found_markers


# âœ¨


@dataclasses.dataclass(frozen=True)
class PathAndValidator:
  """An immutable container for a DM file path and a validator."""
  dm_path: pathlib.Path
  validator: Validator

  async def validate_fields(self):
    """Validates fields, conditionally raising ValueError.

    {{ðŸ¦” Doesn't raise if `dm_path` is a valid file with two markers}}
    {{ðŸ¦” Raises ValueError if `dm_path` is "foo.py"}}
    {{ðŸ¦” Raises ValueError if `dm_path` is a valid Python file with no markers}}
    {{ðŸ¦” Raises ValueError if `dm_path` contains a repeated marker}}

    We can't use `__post_init__` because we want `async` validation.
    """
    # âœ¨ PathAndValidator validate fields
    if ".dm." not in self.dm_path.name:
      raise ValueError(f"DM file path '{self.dm_path}' must contain '.dm.'.")

    try:
      markers = await get_markers(char='ðŸ„', path=self.dm_path)
      if not markers:
        raise ValueError(f"DM file '{self.dm_path}' contains no markers.")
    except FileNotFoundError:
      raise ValueError(f"DM file '{self.dm_path}' does not exist.")
# âœ¨

  def output_path(self) -> pathlib.Path:
    """Returns `dm_path` without the `.dm` part.

    {{ðŸ¦” If `dm_path` is "foo/bar/quux.dm.py", returns "foo/bar/quux.py"}}
    """
    # âœ¨ PathAndValidator output path
    return self.dm_path.parent / self.dm_path.name.replace(".dm.", ".")
# âœ¨

  async def overwrite(self, target: pathlib.Path) -> None:
    """Copies `dm_path`'s contents to `target` (overwriting it).

    The contents of the new file are:

    * A line with the comment:
      "DO NOT EDIT. This file is automatically generated by Duende."
    * The entire (unmodified) contents of `dm_path`.

    {{ðŸ¦” The read operation is async}}
    {{ðŸ¦” The write operation is async}}
    {{ðŸ¦” The output of a call with a normal dm file starts with the "DO NOT EDIT
         code comment}}
    {{ðŸ¦” The output of a call with a normal dm file contains a copy (of the dm
         file), starting at line 2 (of the output)}}
    """
    # âœ¨ overwrite
    if not self.dm_path.exists():
      raise FileNotFoundError(f"DM file not found: {self.dm_path}")

    async with aiofiles.open(self.dm_path, mode="r") as dm_f:
      dm_content = await dm_f.read()

    output_content = "# DO NOT EDIT. This file is automatically generated by Duende.\n" + dm_content

    async with aiofiles.open(target, mode="w") as target_f:
      await target_f.write(output_content)


# âœ¨


async def prepare_initial_message(
    start_message_content: str, relevant_files: list[pathlib.Path]) -> Message:
  """Creates the first message for an AgentLoop conversation.

  {{ðŸ¦” `relevant_files` are read asynchronously}}
  {{ðŸ¦” The output contains `start_message_content` in its first section}}
  {{ðŸ¦” If `relevant_files` is empty, the output has just one section}}
  {{ðŸ¦” There is a content section in the start message given to the AgentLoop
       for each entries in `relevant_files`. It starts with a line
       "File "{path}" follows:" (with the corresponding path) and includes
       the entire contents of the file.}}
  """
  # âœ¨ prepare initial message
  content_sections: list[ContentSection] = []
  content_sections.append(ContentSection(content=start_message_content))

  for file_path in relevant_files:
    async with aiofiles.open(file_path, mode="r") as f:
      file_content = await f.read()
    content_sections.append(
        ContentSection(
            content=f"File \"{file_path}\" follows:\n{file_content}"))

  return Message(role="user", content_sections=content_sections)


# âœ¨


async def prepare_command_registry(
    done_command_arguments: list[Argument],
    done_validator_callback: Callable[[VariableMap],
                                      Awaitable[ValidationResult]],
    file_access_policy: FileAccessPolicy) -> CommandRegistry:
  """Creates a command registry suitable for run_agent_loop.

  {{ðŸ¦” The command registry given has exactly these agent commands:
       ReadFileCommand(â€¦), ListFilesCommand(â€¦), SearchFileCommand(â€¦),
       done_command}}
  """
  # âœ¨ prepare command registry
  registry = CommandRegistry()

  registry.Register(ReadFileCommand(file_access_policy))
  registry.Register(ListFilesCommand(file_access_policy))
  registry.Register(SearchFileCommand(file_access_policy))

  class _DoneValuesValidator(DoneValuesValidator):

    def __init__(self, callback: Callable[[VariableMap],
                                          Awaitable[ValidationResult]]):
      self._callback = callback

    async def validate(self, inputs: VariableMap) -> ValidationResult:
      return await self._callback(inputs)

  registry.Register(
      DoneCommand(
          arguments=done_command_arguments,
          values_validator=_DoneValuesValidator(done_validator_callback)))

  return registry


# âœ¨


async def run_agent_loop(workflow_options: AgentWorkflowOptions,
                         conversation_name: str, start_message: Message,
                         command_registry: CommandRegistry) -> VariableMap:
  """Creates and runs a BaseAgentLoop.

  {{ðŸ¦” Returns the VariableMap with all the values given to DoneCommand}}
  {{ðŸ¦” The conversation started has name `conversation_name`}}
  {{ðŸ¦” `start_message` is given as the initial message}}

  Returns:
    Output variables given to the final `done` command (extracted from the
    final message in the conversation).
  """
  # âœ¨ run agent loop
  # 1. Create a Conversation object.
  conversation = workflow_options.conversation_factory.New(
      name=conversation_name, command_registry=command_registry)

  # 2. Construct AgentLoopOptions by overriding relevant fields from workflow_options.
  updated_agent_loop_options = workflow_options.agent_loop_options._replace(
      conversation=conversation,
      start_message=start_message,
      commands_registry=command_registry,
  )

  # 3. Create an instance of AgentLoop using the factory.
  agent_loop = workflow_options.agent_loop_factory.new(
      updated_agent_loop_options)

  # 4. Run the loop.
  await agent_loop.run()

  # 5. Get the final message from the conversation.
  if not conversation.messages:
    # This case should ideally not happen if the agent loop completes successfully.
    # Returning an empty VariableMap as a fallback.
    return VariableMap({})

  final_message = conversation.messages[-1]

  # 6. Extract the output_variables from the done command's CommandOutput.
  for section in final_message.GetContentSections():
    if section.command_output and section.command_output.task_done:
      return section.command_output.output_variables

  # This part should ideally not be reached if the agent always calls 'done'.
  # However, as a safeguard, return an empty VariableMap.
  return VariableMap({})


# âœ¨
