[
  {
    "role": "system",
    "content_sections": [
      {
        "content": [
          "You are a coding assistant operating in a command loop environment. Send in your response commands prefixed with `#`. I will execute those commands and tell you the results. Do not hallucinate results on your own. Anything that is not a command will be relayed to the human."
        ],
        "summary": "Hard-coded opening instructions."
      },
      {
        "content": [
          "Please try hard to make your code as readable and simple as possible.",
          "",
          "Don't add comments describing the changes you are introducing. That forces me to delete them when the code is submitted, which is a waste of time.",
          "",
          "Only delete unit tests if they have become obsolete because you've removed functionality they test."
        ],
        "summary": "Constant prompt guidance: agent/prompt.txt"
      },
      {
        "content": [
          "Can you add to each message a timestamp with the instant in which it was generated? Call this field `creation_time`.",
          "",
          "Feel free to break reading of previously saved conversations (that's not important). In other words, do not extend the code to deal with loading messages without this timestamp.",
          "",
          "Store it (in Serialize) in the most standard way you can think of.",
          "Note that we will attempt to send the output of Serialize through socketio to the browser.",
          "",
          "Make sure it is stored in UTC format, without local timezone information.",
          ""
        ],
        "summary": "Non-command lines from --task file (conversations/message-timestamp.txt)"
      },
      {
        "content": [
          "#read_file src/conversation.py <<",
          "from typing import List, Dict, Any, Optional, Callable, NamedTuple",
          "import json",
          "import logging",
          "",
          "# Avoid strings with newline characters; to break lines, just add more entries.",
          "MultilineContent = List[str]",
          "",
          "",
          "class ContentSection(NamedTuple):",
          "  content: MultilineContent",
          "  summary: Optional[str] = None",
          "",
          "",
          "class Message:",
          "",
          "  def __init__(self,",
          "               role: str,",
          "               content_sections: Optional[List[ContentSection]] = None):",
          "    self.role = role",
          "    self._content_sections: List[ContentSection] = content_sections if content_sections is not None else []",
          "",
          "  def Serialize(self) -> Dict[str, Any]:",
          "    serialized_sections = []",
          "    for section in self._content_sections:",
          "      section_dict: Dict[str, Any] = {'content': section.content}",
          "      if section.summary is not None:",
          "        section_dict['summary'] = section.summary",
          "      serialized_sections.append(section_dict)",
          "    return {'role': self.role, 'content_sections': serialized_sections}",
          "",
          "  @staticmethod",
          "  def Deserialize(data: Dict[str, Any]) -> 'Message':",
          "    message = Message(role=data['role'])",
          "    raw_sections = data.get('content_sections', [])",
          "    for section_data in raw_sections:",
          "      content = section_data.get('content', [])",
          "      summary = section_data.get('summary')",
          "      message._content_sections.append(",
          "          ContentSection(content=content, summary=summary))",
          "    return message",
          "",
          "  def GetContentSections(self) -> List[ContentSection]:",
          "    return self._content_sections",
          "",
          "  def PushSection(self, section: ContentSection) -> None:",
          "    self._content_sections.append(section)",
          "",
          "",
          "ConversationId = int",
          "",
          "",
          "class Conversation:",
          "",
          "  def __init__(",
          "      self,",
          "      unique_id: int,",
          "      name: str,",
          "      on_message_added_callback: Optional[Callable[[int],",
          "                                                   None]] = None) -> None:",
          "    self._unique_id = unique_id",
          "    self._name = name",
          "    self.messages: List[Message] = []",
          "    self._on_message_added_callback = on_message_added_callback",
          "",
          "  @staticmethod",
          "  def Load(",
          "      unique_id: int,",
          "      path: str,",
          "      name: str,",
          "      on_message_added_callback: Optional[Callable[[ConversationId],",
          "                                                   None]] = None",
          "  ) -> 'Conversation':",
          "    conversation = Conversation(unique_id, name, on_message_added_callback)",
          "    try:",
          "      with open(path, 'r') as f:",
          "        conversation.messages.extend(",
          "            Message.Deserialize(message_data) for message_data in json.load(f))",
          "    except (FileNotFoundError, json.JSONDecodeError):",
          "      logging.info(\"Invalid or missing data. Starting new conversation.\")",
          "    return conversation",
          "",
          "  def Save(self, path: str) -> None:",
          "    with open(path, 'w') as f:",
          "      json.dump([message.Serialize() for message in self.messages], f, indent=2)",
          "",
          "  def AddMessage(self, message: Message) -> None:",
          "    content_sections = message.GetContentSections()",
          "    num_sections = len(content_sections)",
          "    first_section_content_log = \"''\"",
          "    if content_sections:",
          "      content_list = content_sections[0].content",
          "      if content_list:",
          "        first_section_content_log = f\"'{content_list[0][:50]}...'\"",
          "    logging.info(",
          "        f\"Add message: {message.role}: {num_sections} sections, first: {first_section_content_log}\"",
          "    )",
          "    self.messages.append(message)",
          "    if self._on_message_added_callback:",
          "      self._on_message_added_callback(self._unique_id)",
          "",
          "  def GetMessagesList(self) -> List[Message]:",
          "    return self.messages",
          "",
          "  def GetId(self) -> ConversationId:",
          "    return self._unique_id",
          "",
          "  def GetName(self) -> str:",
          "    return self._name",
          "",
          "",
          "class ConversationFactory:",
          "",
          "  def __init__(",
          "      self,",
          "      on_message_added_callback: Optional[Callable[[ConversationId],",
          "                                                   None]] = None",
          "  ) -> None:",
          "    self._next_id: ConversationId = 0",
          "    self._conversations: Dict[ConversationId, Conversation] = {}",
          "    self.on_message_added_callback = on_message_added_callback",
          "",
          "  def New(self, name: str) -> Conversation:",
          "    output = Conversation(self._next_id, name, self.on_message_added_callback)",
          "    self._conversations[self._next_id] = output",
          "    self._next_id += 1",
          "    return output",
          "",
          "  def Load(self, path: str, name: str) -> Conversation:",
          "    output = Conversation.Load(self._next_id, path, name,",
          "                               self.on_message_added_callback)",
          "    self._conversations[self._next_id] = output",
          "    self._next_id += 1",
          "    return output",
          "",
          "  def Get(self, id: ConversationId) -> Conversation:",
          "    return self._conversations[id]",
          "",
          "  def GetAll(self) -> List[Conversation]:",
          "    return list(self._conversations.values())",
          "#end (src/conversation.py)"
        ],
        "summary": "Read file src/conversation.py with 139 lines."
      },
      {
        "content": [
          "#read_file src/web_server_state.py <<",
          "from typing import List, Optional",
          "import argparse",
          "import logging",
          "from flask_socketio import SocketIO",
          "from threading import Thread",
          "",
          "from args_common import CreateAgentLoopOptions",
          "from agent_loop import AgentLoop",
          "from confirmation import AsyncConfirmationManager",
          "from random_key import GenerateRandomKey",
          "from conversation import ConversationFactory, ConversationId, Message",
          "",
          "",
          "class WebServerState:",
          "",
          "  def __init__(self, args: argparse.Namespace, socketio: SocketIO) -> None:",
          "    self.socketio = socketio",
          "    self.confirmation_manager = AsyncConfirmationManager(",
          "        self._confirmation_requested)",
          "    self.session_key = GenerateRandomKey()",
          "",
          "    self.conversation_factory = ConversationFactory(",
          "        lambda id: self.SendUpdate(id, None, confirmation_required=None))",
          "    try:",
          "      options = CreateAgentLoopOptions(args, self.confirmation_manager,",
          "                                       self.conversation_factory)",
          "    except RuntimeError as e:",
          "      logging.error(e)",
          "      raise e",
          "",
          "    Thread(target=AgentLoop(options).run).start()",
          "",
          "  def SendUpdate(self, conversation_id: ConversationId,",
          "                 client_message_count: Optional[int],",
          "                 confirmation_required: Optional[str]) -> None:",
          "    try:",
          "      conversation = self.conversation_factory.Get(conversation_id)",
          "    except KeyError:",
          "      logging.error(",
          "          f\"Conversation with ID {conversation_id} not found. Cannot send update.\"",
          "      )",
          "      return",
          "",
          "    messages_list = conversation.GetMessagesList()",
          "    if client_message_count is not None:",
          "      new_messages = messages_list[client_message_count:]",
          "      logging.info(",
          "          f\"Client has {client_message_count} messages. \"",
          "          f\"Sending from {client_message_count}, count: {len(new_messages)}.\")",
          "    else:",
          "      new_messages = []",
          "      logging.info(\"Sending update without new messages.\")",
          "",
          "    if confirmation_required is None:",
          "      confirmation_required = self.confirmation_manager.get_pending_message()",
          "    data = {",
          "        'conversation_id': conversation_id,",
          "        'conversation_name': conversation.GetName(),",
          "        'confirmation_required': confirmation_required,",
          "        'conversation': [m.Serialize() for m in new_messages],",
          "        'message_count': len(messages_list),",
          "        'session_key': self.session_key,",
          "        'first_message_index': client_message_count or 0",
          "    }",
          "    self.socketio.emit('update', data)",
          "",
          "  def _confirmation_requested(self, conversation_id: ConversationId,",
          "                              message: str) -> None:",
          "    logging.info(\"Confirmation requested.\")",
          "    self.SendUpdate(conversation_id, None, confirmation_required=message)",
          "",
          "  def ReceiveConfirmation(self, confirmation_message: str) -> None:",
          "    logging.info(\"Received confirmation.\")",
          "    self.confirmation_manager.provide_confirmation(confirmation_message)",
          "",
          "  def ListConversations(self) -> None:",
          "    logging.info(\"Listing conversations.\")",
          "    conversations_data = []",
          "    for conversation in self.conversation_factory.GetAll():",
          "      conversations_data.append({",
          "          'id': conversation.GetId(),",
          "          'name': conversation.GetName(),",
          "          'message_count': len(conversation.GetMessagesList()),",
          "      })",
          "    self.socketio.emit('list_conversations', conversations_data)",
          "#end (src/web_server_state.py)"
        ],
        "summary": "Read file src/web_server_state.py with 85 lines."
      },
      {
        "content": [
          "Some commands accept multi-line information, like this:",
          "",
          "#write_file foo.py <<",
          "line0",
          "line1",
          "\u2026",
          "#end",
          "When you're done (or if you get stuck), issue #done to notify the human and stop this conversation.",
          "",
          "Anything sent outside of commands will be treated as plain text.",
          "You can send many commands per message. For example, if you want to read 5 files, you can issue 5 #read_file commands at once.",
          "",
          "Available commands:",
          "#help [command\u2026]",
          "  Shows help for a given command. If none is given, for all commands.",
          "",
          "#list_files [directory\u2026]",
          "  Lists all files in the given directories (or the top-level if none is specified).",
          "",
          "#read_file path",
          "  Outputs the contents of a file.",
          "",
          "#replace_python identifier [path]  <<",
          "The new definition of the Python element.",
          "\u2026",
          "#end",
          "  Replaces the definition of the identifier in the specified Python file. Searches in all Python files if no path is provided. The identifier can be the name of a (top-level) function, class, or method.",
          "",
          "#reset_file [path\u2026]",
          "  Resets files to their original state. AI can use this to reset files it accidentally broke.",
          "",
          "#search content [file\u2026]",
          "  Searches for the specific content in specified files (or in all files).",
          "",
          "#select path start_line_pattern [end_line_pattern]",
          "  Creates a new selection for the content in the path specified. The selection starts at the first line matching a start pattern and ends at the first following line matching an optional end pattern. If no end pattern is provided, only the line matching the start pattern is selected. The contents selected will be returned. Use select_overwrite to overwrite the selection with new contents. If your patterns contain spaces, you probably want to put quotes around them.",
          "",
          "#select_overwrite  <<",
          "New contents to overwrite the current selection.",
          "\u2026",
          "#end",
          "  Replaces the contents of the selection (the very last call to #select or similar command) with new contents.",
          "",
          "#select_python identifier [path]",
          "  Selects the definition of an identifier in a Python file. Searches all Python files if no path is given.",
          "",
          "#select_regex path start_line_pattern [end_line_pattern]",
          "  Creates a new selection for the content in the path specified. The selection starts at the first line matching a start pattern and ends at the first following line matching an optional end pattern. If no end pattern is provided, only the line matching the start pattern is selected. The contents selected will be returned. Use select_overwrite to overwrite the selection with new contents. If your patterns contain spaces, you probably want to put quotes around them.",
          "",
          "#task [task_name]  <<",
          "The specification for the task.",
          "\u2026",
          "#end",
          "  Starts a new conversation with the AI asking it to implement a sub-task. Use this for complex commands, where you would like an agent to implement a specific smaller change. In the specification, include all information you think the AI may need. Some additional information (about the environment) will be included.",
          "",
          "#validate",
          "  Executes validation script to verify code integrity. Recommended to run this command after making changes.",
          "",
          "#write_file path  <<",
          "The content to write into the specified file.",
          "\u2026",
          "#end",
          "  Writes the given content to a specified file.",
          ""
        ],
        "summary": "Commands overview."
      }
    ]
  },
  {
    "role": "assistant",
    "content_sections": [
      {
        "content": [
          "#select_regex src/conversation.py \"^import logging\"",
          "#select_overwrite <<",
          "import logging",
          "from datetime import datetime, timezone",
          "#end",
          "#replace_python Message src/conversation.py <<",
          "class Message:",
          "",
          "  def __init__(self,",
          "               role: str,",
          "               content_sections: Optional[List[ContentSection]] = None,",
          "               creation_time: Optional[datetime] = None):",
          "    self.role = role",
          "    self._content_sections: List[",
          "        ContentSection] = content_sections if content_sections is not None else []",
          "    self.creation_time = creation_time if creation_time is not None else datetime.now(",
          "        timezone.utc)",
          "",
          "  def Serialize(self) -> Dict[str, Any]:",
          "    serialized_sections = []",
          "    for section in self._content_sections:",
          "      section_dict: Dict[str, Any] = {'content': section.content}",
          "      if section.summary is not None:",
          "        section_dict['summary'] = section.summary",
          "      serialized_sections.append(section_dict)",
          "    return {",
          "        'role': self.role,",
          "        'content_sections': serialized_sections,",
          "        'creation_time': self.creation_time.isoformat()",
          "    }",
          "",
          "  @staticmethod",
          "  def Deserialize(data: Dict[str, Any]) -> 'Message':",
          "    content_sections: List[ContentSection] = []",
          "    raw_sections = data.get('content_sections', [])",
          "    for section_data in raw_sections:",
          "      content = section_data.get('content', [])",
          "      summary = section_data.get('summary')",
          "      content_sections.append(ContentSection(content=content, summary=summary))",
          "",
          "    creation_time = datetime.fromisoformat(data['creation_time'])",
          "",
          "    return Message(role=data['role'],",
          "                   content_sections=content_sections,",
          "                   creation_time=creation_time)",
          "",
          "  def GetContentSections(self) -> List[ContentSection]:",
          "    return self._content_sections",
          "",
          "  def PushSection(self, section: ContentSection) -> None:",
          "    self._content_sections.append(section)",
          "#end",
          "#replace_python Conversation.Load src/conversation.py <<",
          "  @staticmethod",
          "  def Load(",
          "      unique_id: int,",
          "      path: str,",
          "      name: str,",
          "      on_message_added_callback: Optional[Callable[[ConversationId],",
          "                                                   None]] = None",
          "  ) -> 'Conversation':",
          "    conversation = Conversation(unique_id, name, on_message_added_callback)",
          "    try:",
          "      with open(path, 'r') as f:",
          "        conversation.messages.extend(",
          "            Message.Deserialize(message_data) for message_data in json.load(f))",
          "    except (FileNotFoundError, json.JSONDecodeError, KeyError):",
          "      logging.info(\"Invalid or missing data. Starting new conversation.\")",
          "    return conversation",
          "#end",
          "#done"
        ]
      }
    ]
  }
]